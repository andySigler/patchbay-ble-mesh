{"ast":null,"code":"import * as utils from './DrawUtils';\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3\n};\n\nclass Finger {\n  constructor(params, onMakeConnection, onDeleteConnection) {\n    this.params = params;\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n    this.didMove = false;\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n    this.topSide = false;\n    this.justErased = false;\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n  }\n\n  update() {\n    if (this.down || this.params.touchedPort) {\n      this.findHover();\n    }\n\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n\n      if (this.params.outCircle.touched) {\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      } else if (this.params.inCircle.touched) {\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover() {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort = undefined;\n    }\n\n    this.findHoveredPort(this.params.outCircle);\n\n    if (this.params.hoveredPort) {\n      return;\n    }\n\n    this.findHoveredPort(this.params.inCircle);\n\n    if (this.params.hoveredPort) {\n      return;\n    }\n  }\n\n  findHoveredPort(circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n\n    if (this.params.touchedPort && this.params.touchedPort.type === circle.type) {\n      return;\n    }\n\n    for (let i = 0; i < 2; i++) {\n      const arcIndex = (i + circle.arcOffset) % circle.arcs.length;\n      const totPorts = circle.arcs[arcIndex].ports.length;\n\n      for (let n = 0; n < totPorts; n++) {\n        const port = circle.arcs[arcIndex].ports[n];\n\n        if (port.isUserTouching(this.x, this.y)) {\n          this.params.hoveredPort = port;\n          break;\n        }\n      }\n    }\n  }\n\n  touchEvent() {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n\n    if (this.handleDeleteConnection()) {\n      return;\n    } // set all connections.hovered to false\n\n\n    for (let n in this.params.connections) {\n      this.params.connections[n].selected = false;\n    }\n\n    this.params.inCircle.clearTouchedHovered();\n    this.params.outCircle.clearTouchedHovered();\n\n    if (this.params.inCircle.isCloseTo(this.x, this.y)) {\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    } else if (this.params.outCircle.isCloseTo(this.x, this.y)) {\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection() {\n    for (let i in this.params.connections) {\n      const conn = this.params.connections[i];\n\n      if (conn.selected) {\n        if (conn.isUserTouching(this.x, this.y)) {\n          this.onDeleteConnection(conn);\n          this.justErased = true;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  resetFromNewCoords(x, y) {\n    if (this.x && this.y) {\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease() {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  releaseWithoutMoving(x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent(); // reset some Finger variables\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease(); // set all connections.hovered to false\n\n    if (!this.justErased) {\n      for (let n in this.params.connections) {\n        this.params.connections[n].selected = false;\n      }\n    } else {\n      this.justErased = false;\n    } // find which Connection is being interacted with\n\n\n    const touchedPort = this.params.touchedPort;\n\n    if (touchedPort) {\n      // then, find the interactive connection\n      for (let n in this.params.connections) {\n        if (this.params.connections[n].inPort === touchedPort) {\n          this.params.connections[n].selected = true;\n        } else if (this.params.connections[n].outPort === touchedPort) {\n          this.params.connections[n].selected = true;\n        }\n      }\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent(x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n\n    if (touchedPort && hoveredPort && hoveredPort !== touchedPort) {\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    for (var n in this.params.connections) {\n      this.params.connections[n].selected = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered() {\n    this.params.inCircle.clearTouchedHovered();\n    this.params.outCircle.clearTouchedHovered();\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  makeConnection(port1, port2) {\n    let inPort;\n    let outPort;\n\n    if (port1.type === this.params.inType) {\n      inPort = port1;\n      outPort = port2;\n    } else {\n      inPort = port2;\n      outPort = port1;\n    }\n\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent(x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n\n    this.resetFromNewCoords(x, y);\n    this.didMove = !justTouched; // determine what side of the screen we're on\n\n    if (this.y > this.params.middleY) this.topSide = true;else this.topSide = false;\n\n    if (!justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n\n    if (justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian(type) {\n    return type === this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter(x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n\n    if (type === this.params.inType) {\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n\n    if (x > middleX) {\n      if (y > middleY) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < middleY) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < middleX) {\n      if (y > middleY) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < middleY) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > middleY) {\n        return Math.PI * 0.5;\n      } else if (y < middleY) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}\n\nexport { Finger };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","fingerDefaults","tapPixelsMovedThresh","Finger","constructor","params","onMakeConnection","onDeleteConnection","x","undefined","y","xStart","yStart","xDiff","yDiff","down","didMove","inRadianDiff","inRadianPrev","inRadianNew","outRadianDiff","outRadianPrev","outRadianNew","topSide","justErased","update","touchedPort","findHover","outCircle","arcs","length","in_radianDiff","out_radianDiff","touched","radiansMoved","inCircle","hoveredPort","findHoveredPort","circle","type","i","arcIndex","arcOffset","totPorts","ports","n","port","isUserTouching","touchEvent","handleDeleteConnection","connections","selected","clearTouchedHovered","isCloseTo","mouseEvent","conn","resetFromNewCoords","resetOnRelease","radianDown","radianDiff","releaseWithoutMoving","tapEvent","inPort","outPort","clearCirclesTouchedHovered","releaseEvent","getDistance","makeConnection","port1","port2","inType","moveEvent","justTouched","middleY","radiansFromCenter","outType","getRadian","middleX","centerX","centerY","yDist","Math","abs","xDist","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\n\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3\n};\n\n\nclass Finger {\n  constructor (params, onMakeConnection, onDeleteConnection) {\n    this.params = params;\n\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n    this.didMove = false;\n\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n\n    this.topSide = false;\n    this.justErased = false;\n\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n  }\n\n  update () {\n    if (this.down || this.params.touchedPort) {\n      this.findHover();\n    }\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n      if(this.params.outCircle.touched){\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      }\n      else if(this.params.inCircle.touched){\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover () {\n    if (!this.params.touchedPort) {\n      return;\n    }\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort = undefined;\n    }\n    this.findHoveredPort(this.params.outCircle);\n    if (this.params.hoveredPort) {\n      return;\n    }\n    this.findHoveredPort(this.params.inCircle);\n    if (this.params.hoveredPort) {\n      return;\n    }\n  }\n\n  findHoveredPort (circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n    if (this.params.touchedPort && this.params.touchedPort.type === circle.type) {\n      return;\n    }\n    for (let i = 0; i < 2; i++) {\n      const arcIndex = (i + circle.arcOffset) % circle.arcs.length;\n      const totPorts = circle.arcs[arcIndex].ports.length;\n      for (let n = 0; n < totPorts; n++) {\n        const port = circle.arcs[arcIndex].ports[n];\n        if (port.isUserTouching(this.x, this.y)) {\n          this.params.hoveredPort = port;\n          break;\n        }\n      }\n    }\n  }\n\n  touchEvent () {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n    // set all connections.hovered to false\n    for(let n in this.params.connections){\n      this.params.connections[n].selected = false;\n    }\n    this.params.inCircle.clearTouchedHovered();\n    this.params.outCircle.clearTouchedHovered();\n    if(this.params.inCircle.isCloseTo(this.x, this.y)){\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    }\n    else if(this.params.outCircle.isCloseTo(this.x, this.y)){\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection () {\n    for(let i in this.params.connections){\n      const conn = this.params.connections[i];\n      if(conn.selected){\n        if (conn.isUserTouching(this.x, this.y)) {\n          this.onDeleteConnection(conn);\n          this.justErased = true;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  resetFromNewCoords (x, y) {\n    if(this.x && this.y){\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease () {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  releaseWithoutMoving (x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent();\n    // reset some Finger variables\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    // set all connections.hovered to false\n    if (!this.justErased) {\n      for(let n in this.params.connections){\n        this.params.connections[n].selected = false;\n      }\n    }\n    else {\n      this.justErased = false;\n    }\n    // find which Connection is being interacted with\n    const touchedPort = this.params.touchedPort;\n    if(touchedPort){\n      // then, find the interactive connection\n      for (let n in this.params.connections){\n        if (this.params.connections[n].inPort === touchedPort){\n          this.params.connections[n].selected = true;\n        }\n        else if (this.params.connections[n].outPort === touchedPort){\n          this.params.connections[n].selected = true;\n        }\n      }\n    }\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent (x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n    if (touchedPort && hoveredPort && hoveredPort !== touchedPort){\n      this.makeConnection(hoveredPort,touchedPort);\n    }\n\n    for (var n in this.params.connections){\n      this.params.connections[n].selected = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered () {\n    this.params.inCircle.clearTouchedHovered();\n    this.params.outCircle.clearTouchedHovered();\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  makeConnection (port1, port2) {\n    let inPort;\n    let outPort;\n    if (port1.type === this.params.inType){\n      inPort = port1;\n      outPort = port2;\n    }\n    else{\n      inPort = port2;\n      outPort = port1;\n    }\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent (x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n    this.resetFromNewCoords(x, y);\n    this.didMove = !justTouched;\n    // determine what side of the screen we're on\n    if (this.y > this.params.middleY) this.topSide = true;\n    else this.topSide = false;\n    if (!justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n    if (justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian (type) {\n    return type === this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter (x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n    if (type === this.params.inType){\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    if (x > middleX){\n      if (y > middleY){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < middleY){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < middleX){\n      if (y > middleY){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < middleY){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > middleY){\n        return Math.PI * 0.5;\n      }\n      else if (y < middleY){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n\nexport { Finger }\n"]},"metadata":{},"sourceType":"module"}