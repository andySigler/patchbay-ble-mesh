{"ast":null,"code":"import * as utils from './DrawUtils';\nimport { AppParams } from './AppParams';\nimport { Connection } from './Connection';\nimport { Finger } from './Finger';\nimport { Circle } from './Circle';\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25\n};\n\nclass Patchbay {\n  constructor(context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(this.params.inType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.params.outCircle = new Circle(this.params.outType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop() {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n\n    this.erase();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  setSize(width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  erase() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection(outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(outputID, outputIndex, inputID, inputIndex);\n\n    if (!this.params.connections[tempName]) {\n      let outPort = undefined;\n      let inPort = undefined; // loop through all the in/out arcs until we have matches for both ports\n\n      for (let h = 0; h < this.params.outCircle.arcs.length; h++) {\n        if (this.params.outCircle.arcs[h].id === outputID) {\n          outPort = this.params.outCircle.arcs[h].ports[outputIndex];\n        }\n\n        if (this.params.inCircle.arcs[h].id === inputID) {\n          inPort = this.params.inCircle.arcs[h].ports[inputIndex];\n        }\n\n        if (outPort && inPort) {\n          this.params.addConnection(tempName, new Connection(this.params.context, outPort, inPort, tempName));\n          break;\n        }\n      }\n    } else {\n      this.params.connections[tempName].exists = true;\n    }\n\n    return tempName;\n  }\n\n}\n\nexport { Patchbay };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Patchbay.js"],"names":["utils","AppParams","Connection","Finger","Circle","patchbayDefaults","tempThickness","screenPercentage","Patchbay","constructor","context","params","inCircle","inType","outCircle","outType","finger","reqAnimFrame","undefined","drawLoop","cancelAnimationFrame","erase","requestAnimationFrame","setSize","width","height","fillStyle","colors","grey","fillRect","createConnection","outputID","inputID","inputIndex","outputIndex","tempName","generateName","connections","outPort","inPort","h","arcs","length","id","ports","addConnection","exists"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { AppParams } from './AppParams'\nimport { Connection } from './Connection'\nimport { Finger } from './Finger'\nimport { Circle } from './Circle'\n\n\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25\n};\n\nclass Patchbay {\n  constructor (context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(\n      this.params.inType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.params.outCircle = new Circle(\n      this.params.outType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop () {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n    this.erase();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  setSize (width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  erase() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection (outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(\n      outputID, outputIndex, inputID, inputIndex);\n    if (!this.params.connections[tempName]) {\n      let outPort = undefined;\n      let inPort = undefined;\n      // loop through all the in/out arcs until we have matches for both ports\n      for (let h = 0; h < this.params.outCircle.arcs.length; h++) {\n        if (this.params.outCircle.arcs[h].id === outputID) {\n          outPort = this.params.outCircle.arcs[h].ports[outputIndex];\n        }\n        if (this.params.inCircle.arcs[h].id === inputID) {\n          inPort = this.params.inCircle.arcs[h].ports[inputIndex];\n        }\n        if (outPort && inPort) {\n          this.params.addConnection(\n            tempName,\n            new Connection(this.params.context, outPort, inPort, tempName)\n          );\n          break;\n        }\n      }\n    }\n    else {\n      this.params.connections[tempName].exists = true;\n    }\n    return tempName;\n  }\n}\n\nexport { Patchbay }\n"]},"metadata":{},"sourceType":"module"}