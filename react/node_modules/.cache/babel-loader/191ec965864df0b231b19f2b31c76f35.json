{"ast":null,"code":"import * as utils from './DrawUtils';\nimport { AppParams } from './AppParams';\nimport { Connection } from './Connection';\nimport { Finger } from './Finger';\nimport { Circle } from './Circle';\nlet counter = 0;\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25,\n  touchCircleThicknessScaler: 0.1,\n  touchedWobbleScaler: 2,\n  touchedLineScaler: 0.05,\n  touchedLineMinWidth: 2,\n  touchedTipPreScaler: 1.25,\n  touchedTipPostScaler: 0.1,\n  hoveredCircleWidthScaler: 0.1\n};\n\nclass Patchbay {\n  constructor(canvas) {\n    this.params = new AppParams(canvas.getContext('2d'));\n    this.params.inCircle = new Circle(this.params, this.params.inType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.params.outCircle = new Circle(this.params, this.params.outType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop() {\n    console.log('\\nDrawLoop');\n\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    } // this.finger.update();\n\n\n    this.params.outCircle.update();\n    this.params.inCircle.update();\n\n    for (let i in this.params.connections) {\n      this.params.connections[i].update();\n    }\n\n    this.params.context.save();\n    this.clearCanvas();\n    this.params.outCircle.drawArcs();\n    this.params.inCircle.drawArcs();\n    this.params.outCircle.drawNames();\n    this.params.inCircle.drawNames();\n    this.params.outCircle.drawPorts();\n    this.params.inCircle.drawPorts();\n\n    for (let i in this.params.connections) {\n      this.params.connections[i].draw();\n    }\n\n    this.drawTouchedPort();\n    this.drawHoveredPort();\n    this.params.context.restore();\n    counter += 1;\n\n    if (counter < 3) {\n      this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop());\n    }\n  }\n\n  drawTouchedPort(fingerX, fingerY) {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const touchCircleThickness = this.params.touchedPort.size * patchbayDefaults.touchCircleThicknessScaler;\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter);\n    touchedLineWidth *= patchbayDefaults.touchedWobbleScaler;\n    touchedLineWidth += Math.max(this.params.touchedPort.size * patchbayDefaults.touchedLineScaler, patchbayDefaults.touchedLineMinWidth);\n    let touchedLineTipCircleScaler = this.params.touchedPort.scaler;\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPreScaler;\n    touchedLineTipCircleScaler = Math.min(touchedLineTipCircleScaler, 1);\n    touchedLineTipCircleScaler = Math.max(touchedLineTipCircleScaler, 0);\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPostScaler;\n    const circleRadius = this.params.touchedPort.size * touchedLineTipCircleScaler; // draw the outlining circle\n\n    this.params.context.save();\n    utils.drawArc(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, this.params.touchedPort.size, 0, utils.PI2, touchCircleThickness, utils.colors.white(), undefined);\n    this.params.context.restore(); // then draw the line, that wobbles its thickness\n\n    this.params.context.save();\n    utils.drawLine(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, fingerX, fingerY, touchedLineWidth, utils.colors.green());\n    this.params.context.restore(); // then two smaller filled in circles to cover the tips of the line\n\n    this.params.context.save();\n    utils.drawArc(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, circleRadius, 0, utils.PI2, 0, undefined, utils.colors.white());\n    utils.drawArc(this.params.context, fingerX, fingerY, circleRadius, 0, utils.PI2, 0, undefined, utils.colors.white());\n    this.params.context.restore();\n  }\n\n  drawHoveredPort() {\n    if (!this.params.hoveredPort) {\n      return;\n    }\n\n    const hoveredCircleWidth = this.params.hoveredPort.size * patchbayDefaults.hoveredCircleWidthScaler;\n    this.params.context.save();\n    utils.drawArc(this.params.context, this.params.hoveredPort.x, this.params.hoveredPort.y, this.params.hoveredPort.size, 0, utils.PI2, hoveredCircleWidth, utils.colors.green(), undefined);\n    this.params.context.restore();\n  }\n\n  setSize(width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.background();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection(outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(outputID, outputIndex, inputID, inputIndex);\n\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    } else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n\n    return tempName;\n  }\n\n  eraseNodeFromConnections(id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n\n}\n\nfunction getPos(e) {\n  return {\n    'x': 0,\n    'y': 0\n  };\n}\n\nfunction touch(event) {\n  // onMouseDown\n  const pos = getPos(event);\n  this.finger.dragEvent(pos.x, pos.y, true);\n  this.finger.touchEvent();\n}\n\nfunction move(event) {\n  // onMouseMove\n  const pos = getPos(event);\n  this.finger.dragEvent(pos.x, pos.y, false);\n}\n\nlet didTap = false;\n\nfunction tap(event) {\n  // onClick\n  didTap = true;\n}\n\nfunction release(event) {\n  // onMouseOut\n  // onMouseLeave\n  // onMouseUp\n  const pos = getPos(event);\n\n  if (didTap) {\n    this.finger.tapEvent(pos.x, pos.y);\n  } else {\n    this.finger.releaseEvent(pos.x, pos.y);\n  }\n\n  if (this.params.hoveredPort) {\n    this.params.hoveredPort.hovered = false;\n    this.params.hoveredPort = undefined;\n  }\n\n  didTap = false;\n}\n\nexport { Patchbay };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Patchbay.js"],"names":["utils","AppParams","Connection","Finger","Circle","counter","patchbayDefaults","tempThickness","screenPercentage","touchCircleThicknessScaler","touchedWobbleScaler","touchedLineScaler","touchedLineMinWidth","touchedTipPreScaler","touchedTipPostScaler","hoveredCircleWidthScaler","Patchbay","constructor","canvas","params","getContext","inCircle","inType","outCircle","outType","finger","reqAnimFrame","undefined","drawLoop","console","log","cancelAnimationFrame","update","i","connections","context","save","clearCanvas","drawArcs","drawNames","drawPorts","draw","drawTouchedPort","drawHoveredPort","restore","requestAnimationFrame","fingerX","fingerY","touchedPort","touchCircleThickness","size","touchedLineWidth","Math","sin","wobbleCounter","max","touchedLineTipCircleScaler","scaler","min","circleRadius","drawArc","x","y","PI2","colors","white","drawLine","green","hoveredPort","hoveredCircleWidth","setSize","width","height","fillStyle","background","fillRect","createConnection","outputID","inputID","inputIndex","outputIndex","tempName","generateName","outPort","getPort","inPort","newConnection","addConnection","exists","eraseNodeFromConnections","id","n","conn","parent","deleteConnection","getPos","e","touch","event","pos","dragEvent","touchEvent","move","didTap","tap","release","tapEvent","releaseEvent","hovered"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { AppParams } from './AppParams'\nimport { Connection } from './Connection'\nimport { Finger } from './Finger'\nimport { Circle } from './Circle'\n\nlet counter = 0;\n\n\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25,\n  touchCircleThicknessScaler: 0.1,\n  touchedWobbleScaler: 2,\n  touchedLineScaler: 0.05,\n  touchedLineMinWidth: 2,\n  touchedTipPreScaler: 1.25,\n  touchedTipPostScaler: 0.1,\n  hoveredCircleWidthScaler: 0.1\n};\n\nclass Patchbay {\n  constructor (canvas) {\n    this.params = new AppParams(canvas.getContext('2d'));\n    this.params.inCircle = new Circle(\n      this.params,\n      this.params.inType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.params.outCircle = new Circle(\n      this.params,\n      this.params.outType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop () {\n    console.log('\\nDrawLoop')\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n    // this.finger.update();\n    this.params.outCircle.update();\n    this.params.inCircle.update();\n    for(let i in this.params.connections){\n      this.params.connections[i].update();\n    }\n\n    this.params.context.save();\n    this.clearCanvas();\n\n    this.params.outCircle.drawArcs();\n    this.params.inCircle.drawArcs();\n\n    this.params.outCircle.drawNames();\n    this.params.inCircle.drawNames();\n\n    this.params.outCircle.drawPorts();\n    this.params.inCircle.drawPorts();\n\n    for(let i in this.params.connections){\n      this.params.connections[i].draw();\n    }\n\n    this.drawTouchedPort();\n    this.drawHoveredPort();\n\n    this.params.context.restore();\n    counter += 1;\n    if (counter < 3) {\n      this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop());\n    }\n  }\n\n  drawTouchedPort (fingerX, fingerY) {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const touchCircleThickness = this.params.touchedPort.size * patchbayDefaults.touchCircleThicknessScaler;\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter);\n    touchedLineWidth *= patchbayDefaults.touchedWobbleScaler;\n    touchedLineWidth += Math.max(\n      this.params.touchedPort.size * patchbayDefaults.touchedLineScaler,\n      patchbayDefaults.touchedLineMinWidth\n    );\n    let touchedLineTipCircleScaler = this.params.touchedPort.scaler;\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPreScaler;\n    touchedLineTipCircleScaler = Math.min(touchedLineTipCircleScaler, 1);\n    touchedLineTipCircleScaler = Math.max(touchedLineTipCircleScaler, 0);\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPostScaler;\n    const circleRadius = this.params.touchedPort.size * touchedLineTipCircleScaler;\n\n    // draw the outlining circle\n    this.params.context.save();\n    utils.drawArc(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y,\n      this.params.touchedPort.size, 0, utils.PI2, touchCircleThickness,\n      utils.colors.white(), undefined\n    );\n    this.params.context.restore();\n\n    // then draw the line, that wobbles its thickness\n    this.params.context.save();\n    utils.drawLine(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y, fingerX, fingerY,\n      touchedLineWidth, utils.colors.green()\n    );\n    this.params.context.restore();\n\n    // then two smaller filled in circles to cover the tips of the line\n    this.params.context.save();\n    utils.drawArc(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y,\n      circleRadius, 0, utils.PI2, 0,\n      undefined, utils.colors.white()\n    );\n    utils.drawArc(\n      this.params.context,\n      fingerX, fingerY,\n      circleRadius, 0, utils.PI2, 0,\n      undefined, utils.colors.white()\n    );\n    this.params.context.restore();\n  }\n\n  drawHoveredPort () {\n    if (!this.params.hoveredPort) {\n      return;\n    }\n    const hoveredCircleWidth = this.params.hoveredPort.size * patchbayDefaults.hoveredCircleWidthScaler;\n    this.params.context.save();\n    utils.drawArc(\n      this.params.context,\n      this.params.hoveredPort.x, this.params.hoveredPort.y,\n      this.params.hoveredPort.size, 0, utils.PI2, hoveredCircleWidth,\n      utils.colors.green(), undefined\n    );\n    this.params.context.restore();\n  }\n\n  setSize (width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.background();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection (outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(\n      outputID, outputIndex, inputID, inputIndex);\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    }\n    else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n    return tempName;\n  }\n\n  eraseNodeFromConnections (id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n}\n\nfunction getPos(e){\n  return {'x': 0, 'y': 0};\n}\n\nfunction touch (event) {\n  // onMouseDown\n  const pos = getPos(event);\n  this.finger.dragEvent(pos.x, pos.y, true);\n  this.finger.touchEvent();\n}\n\nfunction move (event) {\n  // onMouseMove\n  const pos = getPos(event);\n  this.finger.dragEvent(pos.x, pos.y, false);\n}\n\nlet didTap = false;\nfunction tap (event) {\n  // onClick\n  didTap = true;\n}\n\nfunction release (event) {\n  // onMouseOut\n  // onMouseLeave\n  // onMouseUp\n  const pos = getPos(event);\n  if (didTap) {\n    this.finger.tapEvent(pos.x,pos.y);\n  }\n  else {\n    this.finger.releaseEvent(pos.x,pos.y);\n  }\n  if (this.params.hoveredPort) {\n    this.params.hoveredPort.hovered = false;\n    this.params.hoveredPort = undefined;\n  }\n  didTap = false;\n}\n\nexport { Patchbay }\n"]},"metadata":{},"sourceType":"module"}