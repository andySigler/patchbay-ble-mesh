{"ast":null,"code":"import * as utils from './DrawUtils';\nimport { AppParams } from './AppParams';\nimport { Connection } from './Connection';\nimport { Finger } from './Finger';\nimport { Circle } from './Circle';\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25,\n  touchCircleThicknessScaler: 0.1,\n  touchedWobbleScaler: 2,\n  touchedLineScaler: 0.05,\n  touchedLineMinWidth: 2,\n  touchedTipPreScaler: 1.25,\n  touchedTipPostScaler: 0.1\n};\n\nclass Patchbay {\n  constructor(context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(this.params.inType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.params.outCircle = new Circle(this.params.outType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop() {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n\n    this.clearCanvas();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  drawTouchedPort(fingerX, fingerY) {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const touchCircleThickness = this.params.touchedPort.size * patchbayDefaults.touchCircleThicknessScaler;\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter);\n    touchedLineWidth *= patchbayDefaults.touchedWobbleScaler;\n    touchedLineWidth += Math.max(this.params.touchedPort.size * patchbayDefaults.touchedLineScaler, patchbayDefaults.touchedLineMinWidth);\n    let touchedLineTipCircleScaler = this.params.touchedPort.scaler;\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPreScaler;\n    touchedLineTipCircleScaler = Math.min(touchedLineTipCircleScaler, 1);\n    touchedLineTipCircleScaler = Math.max(touchedLineTipCircleScaler, 0);\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPostScaler;\n    const circleRadius = this.params.touchedPort.size * touchedLineTipCircleScaler; // draw the outlining circle\n\n    this.params.context.save();\n    utils.drawArc(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, this.params.touchedPort.size, 0, utils.PI2, touchCircleThickness, utils.colors.white(), undefined);\n    this.params.context.restore(); // then draw the line, that wobbles its thickness\n\n    this.params.context.save();\n    utils.drawLine(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, fingerX, fingerY, touchedLineWidth, utils.colors.green());\n    this.params.context.restore(); // then two smaller filled in circles to cover the tips of the line\n\n    this.params.context.save();\n    utils.drawArc(this.params.context, this.params.touchedPort.x, this.params.touchedPort.y, circleRadius, 0, utils.PI2, 0, undefined, utils.colors.white());\n    utils.drawArc(this.params.context, fingerX, fingerY, circleRadius, 0, utils.PI2, 0, undefined, utils.colors.white());\n    this.params.context.restore();\n  }\n\n  drawHoveredPort() {\n    context.save();\n    context.lineWidth = hoveredPort.size * .1;\n    context.strokeStyle = utils.colors.green();\n    context.beginPath();\n    context.arc(hoveredPort.x, hoveredPort.y, hoveredPort.size, 0, utils.PI2, false);\n    context.stroke();\n    context.restore();\n  }\n\n  setSize(width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection(outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(outputID, outputIndex, inputID, inputIndex);\n\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    } else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n\n    return tempName;\n  }\n\n  eraseNodeFromConnections(id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n\n}\n\nexport { Patchbay };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Patchbay.js"],"names":["utils","AppParams","Connection","Finger","Circle","patchbayDefaults","tempThickness","screenPercentage","touchCircleThicknessScaler","touchedWobbleScaler","touchedLineScaler","touchedLineMinWidth","touchedTipPreScaler","touchedTipPostScaler","Patchbay","constructor","context","params","inCircle","inType","outCircle","outType","finger","reqAnimFrame","undefined","drawLoop","cancelAnimationFrame","clearCanvas","requestAnimationFrame","drawTouchedPort","fingerX","fingerY","touchedPort","touchCircleThickness","size","touchedLineWidth","Math","sin","wobbleCounter","max","touchedLineTipCircleScaler","scaler","min","circleRadius","save","drawArc","x","y","PI2","colors","white","restore","drawLine","green","drawHoveredPort","lineWidth","hoveredPort","strokeStyle","beginPath","arc","stroke","setSize","width","height","fillStyle","grey","fillRect","createConnection","outputID","inputID","inputIndex","outputIndex","tempName","generateName","connections","outPort","getPort","inPort","newConnection","addConnection","exists","eraseNodeFromConnections","id","n","conn","parent","deleteConnection"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { AppParams } from './AppParams'\nimport { Connection } from './Connection'\nimport { Finger } from './Finger'\nimport { Circle } from './Circle'\n\n\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25,\n  touchCircleThicknessScaler: 0.1,\n  touchedWobbleScaler: 2,\n  touchedLineScaler: 0.05,\n  touchedLineMinWidth: 2,\n  touchedTipPreScaler: 1.25,\n  touchedTipPostScaler: 0.1\n};\n\nclass Patchbay {\n  constructor (context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(\n      this.params.inType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.params.outCircle = new Circle(\n      this.params.outType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop () {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n    this.clearCanvas();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  drawTouchedPort (fingerX, fingerY) {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const touchCircleThickness = this.params.touchedPort.size * patchbayDefaults.touchCircleThicknessScaler;\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter);\n    touchedLineWidth *= patchbayDefaults.touchedWobbleScaler;\n    touchedLineWidth += Math.max(\n      this.params.touchedPort.size * patchbayDefaults.touchedLineScaler,\n      patchbayDefaults.touchedLineMinWidth\n    );\n    let touchedLineTipCircleScaler = this.params.touchedPort.scaler;\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPreScaler;\n    touchedLineTipCircleScaler = Math.min(touchedLineTipCircleScaler, 1);\n    touchedLineTipCircleScaler = Math.max(touchedLineTipCircleScaler, 0);\n    touchedLineTipCircleScaler *= patchbayDefaults.touchedTipPostScaler;\n    const circleRadius = this.params.touchedPort.size * touchedLineTipCircleScaler;\n\n    // draw the outlining circle\n    this.params.context.save();\n    utils.drawArc(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y,\n      this.params.touchedPort.size, 0, utils.PI2, touchCircleThickness,\n      utils.colors.white(), undefined\n    );\n    this.params.context.restore();\n\n    // then draw the line, that wobbles its thickness\n    this.params.context.save();\n    utils.drawLine(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y, fingerX, fingerY,\n      touchedLineWidth, utils.colors.green()\n    );\n    this.params.context.restore();\n\n    // then two smaller filled in circles to cover the tips of the line\n    this.params.context.save();\n    utils.drawArc(\n      this.params.context,\n      this.params.touchedPort.x, this.params.touchedPort.y,\n      circleRadius, 0, utils.PI2, 0,\n      undefined, utils.colors.white()\n    );\n    utils.drawArc(\n      this.params.context,\n      fingerX, fingerY,\n      circleRadius, 0, utils.PI2, 0,\n      undefined, utils.colors.white()\n    );\n    this.params.context.restore();\n  }\n\n  drawHoveredPort () {\n    context.save();\n    context.lineWidth = hoveredPort.size * .1;\n    context.strokeStyle = utils.colors.green();\n    context.beginPath();\n    context.arc(hoveredPort.x, hoveredPort.y, hoveredPort.size, 0, utils.PI2, false);\n    context.stroke();\n    context.restore();\n  }\n\n  setSize (width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection (outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(\n      outputID, outputIndex, inputID, inputIndex);\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    }\n    else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n    return tempName;\n  }\n\n  eraseNodeFromConnections (id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n}\n\nexport { Patchbay }\n"]},"metadata":{},"sourceType":"module"}