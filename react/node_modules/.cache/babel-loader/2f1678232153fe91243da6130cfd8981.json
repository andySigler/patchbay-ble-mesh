{"ast":null,"code":"import * as utils from './DrawUtils';\nimport Connection from './Connection';\nconst fingerDefaults = {\n  portHoverDistanceThresh: 0.75\n};\n\nclass Finger {\n  constructor(params) {\n    this.params = params;\n    this.x;\n    this.y;\n    this.xDiff;\n    this.yDiff;\n    this.down = false;\n    this.inRadianDiff;\n    this.inRadianPrev;\n    this.inRadianNew;\n    this.outRadianDiff;\n    this.outRadianPrev;\n    this.outRadianNew;\n    this.topSide = false;\n    this.justErased = false;\n  }\n\n  update() {\n    if (this.down || touchedPort) {\n      this.findHover();\n    }\n\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n\n      if (this.params.outCircle.touched) {\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      } else if (this.params.inCircle.touched) {\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover() {\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort.hovered = false;\n      this.params.hoveredPort = undefined;\n    }\n\n    const outCircle = this.params.outCircle;\n    const inCircle = this.params.inCircle;\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n\n    if (outCircle.touched || inCircle.touched) {\n      return;\n    }\n\n    if (outCircle.arcs.length > 0) {\n      if (touchedPort && touchedPort.type == this.params.inType || !touchedPort) {\n        for (const i = 0; i < 2; i++) {\n          if (hoveredPort || !outCircle.highlighted[String(i)]) {\n            continue;\n          }\n\n          const index = (i + outCircle.arcOffset) % outCircle.arcs.length;\n          const len = outCircle.arcs[index].ports.length;\n\n          for (const n = 0; n < len; n++) {\n            const port = outCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouse.x, mouse.y);\n\n            if (absDiff < port.size * fingerDefaults.portHoverDistanceThresh) {\n              this.params.outCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.outCircle.arcs[index].ports[n];\n              break;\n            } else {\n              this.params.outCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (this.params.hoveredPort || this.params.inCircle.arcs.length <= 0) {\n      return;\n    }\n\n    if (!this.params.touchedPoint || this.params.touchedPort.type == this.params.outType) {\n      //loop through inner seen ports\n      for (var i = 0; i < 2; i++) {\n        if (!hoveredPort && inCircle.highlighted[String(i)]) {\n          var index = (i + inCircle.arcOffset) % inCircle.arcs.length;\n          var len = inCircle.arcs[index].ports.length;\n\n          for (var n = 0; n < len; n++) {\n            const port = this.params.inCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouse.x, mouse.y);\n\n            if (absDiff < port.size / 2) {\n              this.params.inCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.inCircle.arcs[index].ports[n];\n              break;\n            } else {\n              this.params.inCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  touchEvent() {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n\n    if (this.params.inCircle.isCloseTo(this.x, this.y)) {\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    } else if (this.params.outCircle.isCloseTo(this.x, this.y)) {\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection() {\n    for (const i in this.params.connections) {\n      const conn = this.params.connections[i];\n\n      if (conn.hovered) {\n        const tempDist = utils.getDistance(this.x, this.y, conn.deleteX, conn.deleteY);\n\n        if (tempDist < conn.deleteSize) {\n          const receiveID = conn.outPort.parent.id;\n          const routeID = conn.inPort.parent.id;\n          const inportIndex = conn.inPort.index;\n          this.params.sendRoute(receiveID, routeID, inportIndex, this.params.deleteType);\n          this.justErased = true;\n\n          if (this.params.testingGUI) {\n            delete this.params.connections[i];\n          }\n\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  resetFromNewCoords(x, y) {\n    if (this.x && this.y) {\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease() {\n    this.down = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  tapEvent(x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent(); // reset some Finger variables\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    this.justErased = false; // find which Connection is being interacted with\n\n    const touchedPort = this.params.touchedPort;\n\n    if (touchedPort) {\n      // set all to hovered to false\n      for (const n in this.params.connections) {\n        this.params.connections[n].hovered = false;\n      } // then, find the interactive connection\n\n\n      for (const n in this.params.connections) {\n        if (this.params.connections[n].inPort === touchedPort) {\n          this.params.connections[n].hovered = true;\n        } else if (this.params.connections[n].outPort === touchedPort) {\n          this.params.connections[n].hovered = true;\n        }\n      }\n    }\n\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  releaseEvent(x, y) {\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n\n    if (touchedPort && hoveredPort && hoveredPort != touchedPort) {\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n\n    for (var n in this.params.connections) {\n      this.params.connections[n].hovered = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  makeConnection(port1, port2) {\n    let inPort;\n    let outPort;\n\n    if (port1.type === self.params.inType) {\n      inPort = port1;\n      outPort = port2;\n    } else {\n      inPort = port2;\n      outPort = port1;\n    }\n\n    const tempName = Connection.generateName(inPort, outPort);\n\n    if (!this.params.connections[tempName]) {\n      const receiverID = outPort.parent.id;\n      const senderID = inPort.parent.id;\n      this.params.sendRoute(receiverID, senderID, inPort.index, outPort.index);\n    }\n  }\n\n  dragEvent(x, y, initRadians) {\n    this.resetFromNewCoords(x, y); // determine what side of the screen we're on\n\n    if (this.y > this.params.middleY) this.topSide = true;else this.topSide = false;\n\n    if (!initRadians) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n\n    if (initRadians) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian(type) {\n    return type == this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter(x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n\n    if (type === this.params.inType) {\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    let radFromCenter;\n\n    if (x > middleX) {\n      if (y > middleY) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < middleY) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < middleX) {\n      if (y > middleY) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < middleY) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > middleY) {\n        return Math.PI * 0.5;\n      } else if (y < middleY) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","Connection","fingerDefaults","portHoverDistanceThresh","Finger","constructor","params","x","y","xDiff","yDiff","down","inRadianDiff","inRadianPrev","inRadianNew","outRadianDiff","outRadianPrev","outRadianNew","topSide","justErased","update","touchedPort","findHover","outCircle","arcs","length","in_radianDiff","out_radianDiff","touched","radiansMoved","inCircle","hoveredPort","hovered","undefined","type","inType","i","highlighted","String","index","arcOffset","len","ports","n","port","absDiff","getDistance","mouse","size","touchedPoint","outType","touchEvent","handleDeleteConnection","isCloseTo","mouseEvent","connections","conn","tempDist","deleteX","deleteY","deleteSize","receiveID","outPort","parent","id","routeID","inPort","inportIndex","sendRoute","deleteType","testingGUI","resetFromNewCoords","resetOnRelease","radianDown","radianDiff","tapEvent","releaseEvent","makeConnection","clearCirclesTouchedHovered","port1","port2","self","tempName","generateName","receiverID","senderID","dragEvent","initRadians","middleY","radiansFromCenter","getRadian","middleX","centerX","centerY","yDist","Math","abs","xDist","radFromCenter","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport Connection from './Connection'\n\nconst fingerDefaults = {\n  portHoverDistanceThresh: 0.75\n};\n\n\nclass Finger {\n  constructor (params) {\n    this.params = params;\n\n    this.x;\n    this.y;\n    this.xDiff;\n    this.yDiff;\n    this.down = false;\n\n    this.inRadianDiff;\n    this.inRadianPrev;\n    this.inRadianNew;\n    this.outRadianDiff;\n    this.outRadianPrev;\n    this.outRadianNew;\n\n    this.topSide = false;\n    this.justErased = false;\n  }\n\n  update () {\n    if (this.down || touchedPort) {\n      this.findHover();\n    }\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n      if(this.params.outCircle.touched){\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      }\n      else if(this.params.inCircle.touched){\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover () {\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort.hovered = false;\n      this.params.hoveredPort = undefined;\n    }\n    const outCircle = this.params.outCircle;\n    const inCircle = this.params.inCircle;\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n    if (outCircle.touched || inCircle.touched) {\n      return;\n    }\n    if (outCircle.arcs.length > 0) {\n      if ((touchedPort && touchedPort.type == this.params.inType) || !touchedPort) {\n        for (const i = 0; i < 2; i++) {\n          if (hoveredPort || !outCircle.highlighted[String(i)]) {\n            continue;\n          }\n          const index = (i + outCircle.arcOffset) % outCircle.arcs.length;\n          const len = outCircle.arcs[index].ports.length;\n          for (const n = 0; n < len; n++) {\n            const port = outCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouse.x, mouse.y);\n            if (absDiff < port.size * fingerDefaults.portHoverDistanceThresh) {\n              this.params.outCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.outCircle.arcs[index].ports[n];\n              break;\n            }\n            else {\n              this.params.outCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n    if (this.params.hoveredPort || this.params.inCircle.arcs.length <= 0) {\n      return;\n    }\n    if (!this.params.touchedPoint || this.params.touchedPort.type == this.params.outType) {\n      //loop through inner seen ports\n      for (var i = 0; i < 2; i++) {\n        if (!hoveredPort && inCircle.highlighted[String(i)]) {\n          var index = (i + inCircle.arcOffset) % inCircle.arcs.length;\n          var len = inCircle.arcs[index].ports.length;\n          for (var n = 0; n < len; n++) {\n            const port = this.params.inCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouse.x, mouse.y);\n            if (absDiff < port.size / 2) {\n              this.params.inCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.inCircle.arcs[index].ports[n];\n              break;\n            }\n            else {\n              this.params.inCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  touchEvent () {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n    if(this.params.inCircle.isCloseTo(this.x, this.y)){\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    }\n    else if(this.params.outCircle.isCloseTo(this.x, this.y)){\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection () {\n    for(const i in this.params.connections){\n      const conn = this.params.connections[i];\n      if(conn.hovered){\n        const tempDist = utils.getDistance(\n          this.x, this.y, conn.deleteX, conn.deleteY);\n        if(tempDist < conn.deleteSize){\n          const receiveID = conn.outPort.parent.id;\n          const routeID = conn.inPort.parent.id;\n          const inportIndex = conn.inPort.index;\n          this.params.sendRoute(\n            receiveID, routeID, inportIndex, this.params.deleteType);\n          this.justErased = true;\n          if (this.params.testingGUI) {\n            delete this.params.connections[i];\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  resetFromNewCoords (x, y) {\n    if(this.x && this.y){\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease () {\n    this.down = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  tapEvent (x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent();\n\n    // reset some Finger variables\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    this.justErased = false;\n    // find which Connection is being interacted with\n    const touchedPort = this.params.touchedPort;\n    if(touchedPort){\n      // set all to hovered to false\n      for(const n in this.params.connections){\n        this.params.connections[n].hovered = false;\n      }\n      // then, find the interactive connection\n      for (const n in this.params.connections){\n        if (this.params.connections[n].inPort === touchedPort){\n          this.params.connections[n].hovered = true;\n        }\n        else if (this.params.connections[n].outPort === touchedPort){\n          this.params.connections[n].hovered = true;\n        }\n      }\n    }\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  releaseEvent (x, y) {\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n    if (touchedPort && hoveredPort && hoveredPort != touchedPort){\n      this.makeConnection(hoveredPort,touchedPort);\n    }\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n\n    for (var n in this.params.connections){\n      this.params.connections[n].hovered = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  makeConnection (port1, port2) {\n    let inPort;\n    let outPort;\n    if (port1.type === self.params.inType){\n      inPort = port1;\n      outPort = port2;\n    }\n    else{\n      inPort = port2;\n      outPort = port1;\n    }\n    const tempName = Connection.generateName(inPort, outPort);\n    if (!this.params.connections[tempName]){\n      const receiverID = outPort.parent.id;\n      const senderID = inPort.parent.id;\n      this.params.sendRoute(receiverID, senderID, inPort.index, outPort.index);\n    }\n  }\n\n  dragEvent (x, y, initRadians) {\n    this.resetFromNewCoords(x, y);\n    // determine what side of the screen we're on\n    if (this.y > this.params.middleY) this.topSide = true;\n    else this.topSide = false;\n    if (!initRadians){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n    if  (initRadians){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian (type) {\n    return type == this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter (x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n    if (type === this.params.inType){\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    let radFromCenter;\n    if (x > middleX){\n      if (y > middleY){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < middleY){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < middleX){\n      if (y > middleY){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < middleY){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > middleY){\n        return Math.PI * 0.5;\n      }\n      else if (y < middleY){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}