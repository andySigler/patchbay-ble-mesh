{"ast":null,"code":"import * as utils from './DrawUtils';\nconst circleDefaults = {\n  autoStepTotal: 20,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 100,\n  outPaddingScaler: 0.5,\n  isCloseToScaler: 0.4\n};\n\nclass Circle {\n  constructor(params, type, radiusPercentage, thickness) {\n    this.params = params;\n    this._radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thickness;\n    this._lineWidth;\n    this._centerX = 0;\n    this._centerY = 0;\n    this._arcOffset = 0;\n    this.targetOffset = 0;\n    this.isAutoMoving = false;\n    this.autoStepTotal = circleDefaults.autoStepTotal;\n    this.autoStepCount = 0;\n    this.autoStepSize = 0;\n    this.targetArc = 0;\n    this._highlighted = {\n      0: true,\n      1: false\n    };\n    this.animPercent = 0;\n    this.animDirection = -1;\n    this._touched = false;\n    this._type = type;\n    this._arcs = [];\n    this.arcEndPoints = [];\n    this._radiansMoved = 0;\n    this.rotateFeedback = circleDefaults.rotateFeedback;\n    this.padding = circleDefaults.padding;\n\n    if (this._type === this.params.outType) {\n      this.padding *= circleDefaults.outPaddingScaler;\n    }\n  } // GETTERS\n\n\n  get type() {\n    return this._type;\n  }\n\n  get highlighted() {\n    return this._highlighted;\n  }\n\n  get lineWidth() {\n    return this._lineWidth;\n  }\n\n  get arcOffset() {\n    return this._arcOffset;\n  }\n\n  get radiusPercentage() {\n    return this._radiusPercentage;\n  }\n\n  get touched() {\n    return this._touched;\n  }\n\n  get arcs() {\n    return this._arcs;\n  }\n\n  get radiansMoved() {\n    return this._radiansMoved;\n  }\n\n  get centerX() {\n    return this._centerX;\n  }\n\n  get centerY() {\n    return this._centerY;\n  } // SETTERS\n\n\n  set radiansMoved(newVal) {\n    this._radiansMoved = newVal;\n  }\n\n  set centerX(newVal) {\n    this._centerX = newVal;\n  }\n\n  set centerY(newVal) {\n    this._centerY = newVal;\n  }\n\n  update(screenSize) {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    } else {\n      this.rotateDrag();\n    }\n\n    const totalArcs = this._arcs.length;\n\n    if (this._arcOffset < totalArcs) {\n      for (const i = 0; i < totalArcs; i++) {\n        const nonHighlightedIndex = (i + this._arcOffset) % totalArcs;\n        const arcIndex = i === 0 ? this._arcOffset : nonHighlightedIndex;\n        const points = this.transpose(i);\n\n        this._arcs[arcIndex].update(points[0], points[1], this._radiusPercentage * screenSize, this._lineWidth, this.padding, this._highlighted[i]);\n      }\n    }\n  }\n\n  drawArcs() {\n    if (this._arcs.length > 0) {\n      this.params.context.save();\n      this.params.context.translate(this._centerX, this._centerY);\n      this.params.context.textAlign = 'center'; // draw the TYPE text in the center of the Circle\n\n      const typeFontSize = Math.floor(this.params.scaler * 0.025);\n      const labelOffsetYScaler = this._type == this.params.inType ? -2 : 2;\n      const typeYOffset = typeFontSize * labelOffsetYScaler;\n      this.params.context.font = typeFontSize + 'px Helvetica';\n      this.params.context.fillStyle = 'black';\n      this.params.context.fillText(this._type.toUpperCase(), 0, typeYOffset);\n      const xOffsetScaler = 0.05;\n      const arcTextScaler = Math.floor(this.params.scaler * 0.04); // then draw the currently displayed arc's name\n\n      const arc0 = this._arcs[this._arcOffset];\n      const arc0FontSize = arcTextScaler * arc0.scaler;\n      let xOffset_0 = this.lineWidth * arcTextScaler * xOffsetScaler * this.animPercent * 1.5;\n\n      if (arc0.type == this.params.outType) {\n        xOffset_0 *= -1;\n      }\n\n      this.params.context.font = arc0FontSize + 'px Helvetica';\n      this.params.context.fillStyle = arc0.color(Math.min(arc0.scaler, 1));\n      this.params.context.fillText(arc0.name, xOffset_0, 0); // draw the next-in-line Arc's label (fading in/out)\n\n      const arc_1 = this._arcs[(this._arcOffset + 1) % this._arcs.length];\n      const arc1FontSize = arcTextScaler * arc_1.scaler;\n      let xOffset_1 = this.lineWidth * arcTextScaler * xOffsetScaler * (1 - this.animPercent);\n\n      if (arc_1.type == this.params.outType) {\n        xOffset_1 *= -1;\n      }\n\n      this.params.context.font = arc1FontSize + 'px Helvetica';\n      this.params.context.fillStyle = arc_1.color(Math.min(arc_1.scaler, 1));\n      this.params.context.fillText(arc_1.name, xOffset_1 * 1.5, 0); // now draw the actual child Arcs\n\n      for (const i = 0; i < totalArcs; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.params.context.restore();\n    }\n  }\n\n  drawNames() {\n    this.params.context.save();\n    this.params.context.translate(this._centerX, this._centerY);\n\n    if (!this.params.touchedPort || this.params.touchedPort.type != this.type) {\n      for (const i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].isSelected) {\n          this._arcs[i].drawName();\n        }\n      }\n    } else {\n      // the touched port is in this circle, so only draw it's name\n      const portStart = this.params.touchedPort.parent.start;\n      const portRotStep = this.params.touchedPort.parent.rotStep;\n      const portRelRadsToPort = portRotStep * this.params.touchedPort.index;\n      const rotateToTouchedPort = portStart + portRotStep / 2 + portRelRadsToPort;\n      this.params.context.save();\n      this.params.context.rotate(rotateToTouchedPort);\n      this.params.touchedPort.drawName();\n      this.params.context.restore();\n    }\n\n    this.params.context.restore();\n  }\n\n  drawPorts() {\n    this.params.context.save();\n    this.params.context.translate(this._centerX, this._centerY);\n    const totalArcs = this._arcs.length;\n    const touchedPort = this.params.touchedPort;\n    const sizeScaler = this._arcOffset === i ? 1 - this.animPercent : this.animPercent;\n\n    for (const i = 0; i < totalArcs; i++) {\n      if (this._arcs[i].isSelected) {\n        // don't draw the port, if it's in this Circle, and doesn't belong to this Arc\n        if (touchedPort && touchedPort.type === this._type && touchedPort.parent !== this._arcs[i]) {\n          continue;\n        }\n\n        this._arcs[i].drawPorts(sizeScaler);\n      }\n    }\n\n    this.params.context.restore();\n  }\n\n  startAutoMove(newOffset) {\n    this.targetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this._arcOffset + this._arcs.length);\n    const moveDown = newOffset - this._arcOffset;\n    const amountToMove = moveUp - this.animPercent;\n\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        amountToMove = moveDown + this._arcs.length + this.animPercent;\n      } else if (moveDown === 0) {\n        amountToMove = (moveDown - this.animPercent) % this._arcs.length;\n      } else {\n        amountToMove = (moveDown + this.animPercent) % this._arcs.length;\n      }\n    }\n\n    this.autoStepSize = amountToMove / this.autoStepTotal;\n    this.autoStepCount = 0; // if (this._arcs[this._arcOffset]) this._arcs[this._arcOffset].scaler = 0;\n    // this._arcOffset = newOffset;\n    // this.animPercent = 0;\n  }\n\n  updateAutoMoving() {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.animPercent += this.autoStepSize;\n      this.autoStepCount++;\n\n      if (this.animPercent >= 1) {\n        this._arcOffset -= this.animDirection;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.animPercent = 0;\n      } else if (this.animPercent < 0) {\n        this._arcOffset += this.animDirection;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.animPercent = 1 + this.animPercent;\n      }\n    } else {\n      this.isAutoMoving = false;\n      this._arcOffset = this.targetOffset;\n      this.animPercent = 0;\n    }\n  }\n\n  transpose(i) {\n    const realStart = this.arcEndPoints[i].start;\n    const realEnd = this.arcEndPoints[i].end;\n    let target = i + this.animDirection;\n\n    if (target < 0) {\n      target = this._arcs.length + target;\n    } else if (target >= this._arcs.length) {\n      target = target % this._arcs.length;\n    }\n\n    let startDiff = this.arcEndPoints[target].star - realStart;\n    let endDiff = this.arcEndPoints[target].end - realEnd;\n\n    if (i === 0 && this.animDirection === 1) {\n      startDiff = startDiff * -1;\n      endDiff = endDiff + utils.PI2;\n    } else if (i === 1 && this.animDirection === -1) {\n      startDiff = startDiff * -1;\n      endDiff = utils.PI2 + endDiff;\n    }\n\n    let currentStart = startDiff * this.animPercent + realStart;\n    let currentEnd = endDiff * this.animPercent + realEnd;\n\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    } else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    } else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n\n    const highlightCuttoff = 1 / 50;\n\n    if (this.animPercent >= 0 && this.animPercent < highlightCuttoff) {\n      this._highlighted = {\n        0: true,\n        1: false\n      };\n    } else if (this.animPercent >= highlightCuttoff && this.animPercent < 0.5) {\n      this._highlighted = {\n        0: true,\n        1: true\n      };\n    } else if (this.animPercent >= 0.5 && this.animPercent < 1 - highlightCuttoff) {\n      this._highlighted = {\n        0: true,\n        1: true\n      };\n    } else if (this.animPercent >= 1 - highlightCuttoff && this.animPercent < 1) {\n      this._highlighted = {\n        0: false,\n        1: true\n      };\n    }\n\n    return [currentStart, currentEnd];\n  }\n\n  mouseEvent(mouseX, mouseY, compRadian) {\n    for (const i in this._highlighted) {\n      if (this._highlighted[i]) {\n        const arcIndex = (i + this._arcOffset) % this._arcs.length;\n        let scaler = this.animPercent * 1.25;\n\n        if (i === 0) {\n          scaler = 1 - scaler;\n        }\n\n        if (this._arcs[arcIndex].isTouchingPort(mouseX, mouseY, scaler)) {\n          this._touched = false;\n          return;\n        }\n      }\n    }\n\n    this._touched = true; // see which arc was touched\n\n    for (const n = 0; n < this._arcs.length; n++) {\n      if (n === this._arcOffset && this._type === this.params.inType) {\n        compRadian += utils.PI2;\n      }\n\n      if (compRadian > this._arcs[n].start && compRadian < this._arcs[n].end) {\n        this._arcs[n].touched = true;\n        break;\n      }\n    }\n  }\n\n  rotateDrag() {\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = (utils.PI - this._radiansMoved % utils.PI) * -1;\n    }\n\n    if (this._radiansMoved < -utils.PI / 2) {\n      this._radiansMoved = utils.PI - Math.abs(this._radiansMoved) % utils.PI;\n    }\n\n    if (!this.touched) {\n      this._radiansMoved *= this.rotateFeedback;\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - relativeMovement % 1;\n    } else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + relativeMovement % 1;\n    }\n\n    if (relativeMovement && relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      } else {\n        this.direction = 1;\n      }\n\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.animPercent -= animStep;\n\n      if (this.animPercent >= 1) {\n        this._arcOffset -= this.animDirection;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.animPercent = 0;\n      } else if (this.animPercent < 0) {\n        this._arcOffset += this.animDirection;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.animPercent = 1 + this.animPercent;\n      }\n    }\n  }\n\n  addArc(name, color, id) {\n    const tempArc = new Arc(this.params, this, this._type, color, name, id, this._arcs.length);\n\n    this._arcs.push(tempArc);\n\n    this.updateDimensionStuff();\n  }\n\n  deleteArc(id) {\n    for (const i = 0; i < this._arcs.length; i++) {\n      if (this._arcs[i].id === id) {\n        this._arcs.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (this._arcOffset >= this._arcs.length && this._arcOffset > 0) {\n      this._arcOffset = this._arcs.length - 1;\n    }\n\n    this.updateDimensionStuff();\n  }\n\n  updateDimensionStuff() {\n    this.arcEndPoints = [];\n\n    if (this._arcs.length === 1) {\n      this.arcEndPoints = [{\n        'start': utils.PI / 2,\n        'end': utils.PI / 2\n      }];\n    } else if (this._arcs.length === 2) {\n      this.arcEndPoints = [{\n        'start': utils.PI,\n        'end': utils.PI2\n      }, {\n        'start': 0,\n        'end': utils.PI\n      }];\n    } else {\n      this.arcEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n\n      for (const i = 1; i < this._arcs.length; i++) {\n        this.arcEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  isCloseTo(x, y) {\n    const distFromCenter = utils.getDistance(this._centerX, this._centerY, x, y);\n    const w = this._lineWidth * circleDefaults.isCloseToScaler;\n    const outerRad = this._radiusPercentage * this.params.scaler + w;\n    const innerRad = this._radiusPercentage * this.params.scaler - w;\n\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n\n    return false;\n  }\n\n  tapEvent() {\n    if (this._touched) {\n      for (const i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered() {\n    this._touched = false;\n\n    for (const i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n\n      for (const n = 0; n < this._arcs[i].ports.length; n++) {\n        this._arcs[i].ports[n].touched = false;\n        this._arcs[i].ports[n].hovered = false;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Circle.js"],"names":["utils","circleDefaults","autoStepTotal","rotateFeedback","padding","PI","outPaddingScaler","isCloseToScaler","Circle","constructor","params","type","radiusPercentage","thickness","_radiusPercentage","relativeLineWidth","_lineWidth","_centerX","_centerY","_arcOffset","targetOffset","isAutoMoving","autoStepCount","autoStepSize","targetArc","_highlighted","animPercent","animDirection","_touched","_type","_arcs","arcEndPoints","_radiansMoved","outType","highlighted","lineWidth","arcOffset","touched","arcs","radiansMoved","centerX","centerY","newVal","update","screenSize","updateAutoMoving","rotateDrag","totalArcs","length","i","nonHighlightedIndex","arcIndex","points","transpose","drawArcs","context","save","translate","textAlign","typeFontSize","Math","floor","scaler","labelOffsetYScaler","inType","typeYOffset","font","fillStyle","fillText","toUpperCase","xOffsetScaler","arcTextScaler","arc0","arc0FontSize","xOffset_0","color","min","name","arc_1","arc1FontSize","xOffset_1","drawArc","restore","drawNames","touchedPort","isSelected","drawName","portStart","parent","start","portRotStep","rotStep","portRelRadsToPort","index","rotateToTouchedPort","rotate","drawPorts","sizeScaler","startAutoMove","newOffset","moveUp","moveDown","amountToMove","abs","realStart","realEnd","end","target","startDiff","star","endDiff","PI2","currentStart","currentEnd","highlightCuttoff","mouseEvent","mouseX","mouseY","compRadian","isTouchingPort","n","relativeMovement","direction","animStep","addArc","id","tempArc","Arc","push","updateDimensionStuff","deleteArc","splice","smallerWidth","isCloseTo","x","y","distFromCenter","getDistance","w","outerRad","innerRad","tapEvent","clearTouchedHovered","ports","hovered"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\n\nconst circleDefaults = {\n  autoStepTotal: 20,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 100,\n  outPaddingScaler: 0.5,\n  isCloseToScaler: 0.4\n};\n\nclass Circle {\n  constructor (params, type, radiusPercentage, thickness) {\n    this.params = params;\n\n    this._radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thickness;\n    this._lineWidth;\n\n    this._centerX = 0;\n    this._centerY = 0;\n\n    this._arcOffset = 0;\n    this.targetOffset = 0;\n    this.isAutoMoving = false;\n    this.autoStepTotal = circleDefaults.autoStepTotal;\n    this.autoStepCount = 0;\n    this.autoStepSize = 0;\n    this.targetArc = 0;\n\n    this._highlighted = {\n      0: true,\n      1: false\n    };\n\n    this.animPercent = 0;\n    this.animDirection = -1;\n\n    this._touched = false;\n\n    this._type = type;\n\n    this._arcs = [];\n\n    this.arcEndPoints = [];\n\n    this._radiansMoved = 0;\n    this.rotateFeedback = circleDefaults.rotateFeedback;\n\n    this.padding = circleDefaults.padding;\n    if (this._type === this.params.outType) {\n      this.padding *= circleDefaults.outPaddingScaler;\n    }\n  }\n\n  // GETTERS\n\n  get type () { return this._type; }\n\n  get highlighted () { return this._highlighted; }\n\n  get lineWidth () { return this._lineWidth; }\n\n  get arcOffset () { return this._arcOffset; }\n\n  get radiusPercentage () { return this._radiusPercentage; }\n\n  get touched () { return this._touched; }\n\n  get arcs () { return this._arcs; }\n\n  get radiansMoved () { return this._radiansMoved; }\n\n  get centerX () { return this._centerX; }\n\n  get centerY () { return this._centerY; }\n\n  // SETTERS\n\n  set radiansMoved (newVal) { this._radiansMoved = newVal; }\n\n  set centerX (newVal) { this._centerX = newVal; }\n\n  set centerY (newVal) { this._centerY = newVal; }\n\n  update (screenSize) {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    }\n    else {\n      this.rotateDrag();\n    }\n    const totalArcs = this._arcs.length;\n    if (this._arcOffset < totalArcs) {\n      for (const i = 0; i < totalArcs; i++) {\n        const nonHighlightedIndex = (i + this._arcOffset) % totalArcs;\n        const arcIndex = (i === 0) ? this._arcOffset : nonHighlightedIndex;\n        const points = this.transpose(i);\n        this._arcs[arcIndex].update(\n          points[0],\n          points[1],\n          this._radiusPercentage * screenSize,\n          this._lineWidth,\n          this.padding,\n          this._highlighted[i]\n        );\n      }\n    }\n  }\n\n  drawArcs () {\n    if (this._arcs.length > 0) {\n      this.params.context.save();\n      this.params.context.translate(this._centerX, this._centerY);\n      this.params.context.textAlign = 'center';\n\n      // draw the TYPE text in the center of the Circle\n      const typeFontSize = Math.floor(this.params.scaler * 0.025);\n      const labelOffsetYScaler = (this._type == this.params.inType) ? -2 : 2;\n      const typeYOffset = typeFontSize * labelOffsetYScaler;\n      this.params.context.font = typeFontSize + 'px Helvetica';\n      this.params.context.fillStyle = 'black';\n      this.params.context.fillText(this._type.toUpperCase(), 0, typeYOffset);\n\n      const xOffsetScaler = 0.05;\n      const arcTextScaler = Math.floor(this.params.scaler * 0.04);\n\n      // then draw the currently displayed arc's name\n      const arc0 = this._arcs[this._arcOffset];\n      const arc0FontSize = arcTextScaler * arc0.scaler;\n      let xOffset_0 = this.lineWidth * arcTextScaler * xOffsetScaler * this.animPercent * 1.5;\n      if (arc0.type == this.params.outType) {\n        xOffset_0 *= -1;\n      }\n      this.params.context.font = arc0FontSize + 'px Helvetica';\n      this.params.context.fillStyle = arc0.color(Math.min(arc0.scaler, 1));\n      this.params.context.fillText(arc0.name, xOffset_0, 0);\n\n      // draw the next-in-line Arc's label (fading in/out)\n      const arc_1 = this._arcs[(this._arcOffset + 1) % this._arcs.length];\n      const arc1FontSize = arcTextScaler * arc_1.scaler;\n      let xOffset_1 = this.lineWidth * arcTextScaler * xOffsetScaler * (1 - this.animPercent);\n      if (arc_1.type==this.params.outType) {\n        xOffset_1 *= -1;\n      }\n      this.params.context.font = arc1FontSize + 'px Helvetica';\n      this.params.context.fillStyle = arc_1.color(Math.min(arc_1.scaler, 1));\n      this.params.context.fillText(arc_1.name, xOffset_1 * 1.5, 0);\n\n      // now draw the actual child Arcs\n      for (const i = 0; i < totalArcs; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.params.context.restore();\n    }\n  }\n\n  drawNames () {\n    this.params.context.save();\n    this.params.context.translate(this._centerX, this._centerY);\n    if (!this.params.touchedPort || this.params.touchedPort.type != this.type) {\n      for (const i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].isSelected) {\n          this._arcs[i].drawName();\n        }\n      }\n    }\n    else {\n      // the touched port is in this circle, so only draw it's name\n      const portStart = this.params.touchedPort.parent.start;\n      const portRotStep = this.params.touchedPort.parent.rotStep;\n      const portRelRadsToPort = portRotStep * this.params.touchedPort.index;\n      const rotateToTouchedPort = portStart + (portRotStep / 2) + portRelRadsToPort;\n      this.params.context.save();\n      this.params.context.rotate(rotateToTouchedPort);\n      this.params.touchedPort.drawName();\n      this.params.context.restore();\n    }\n    this.params.context.restore();\n  }\n\n  drawPorts () {\n    this.params.context.save();\n    this.params.context.translate(this._centerX, this._centerY);\n    const totalArcs = this._arcs.length;\n    const touchedPort = this.params.touchedPort;\n    const sizeScaler = (this._arcOffset === i) ? 1 - this.animPercent : this.animPercent;\n    for (const i = 0; i < totalArcs; i++) {\n      if (this._arcs[i].isSelected) {\n        // don't draw the port, if it's in this Circle, and doesn't belong to this Arc\n        if (touchedPort && touchedPort.type === this._type && touchedPort.parent !== this._arcs[i]) {\n          continue\n        }\n        this._arcs[i].drawPorts(sizeScaler);\n      }\n    }\n    this.params.context.restore();\n  }\n\n  startAutoMove (newOffset) {\n    this.targetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this._arcOffset + this._arcs.length);\n    const moveDown = newOffset - this._arcOffset;\n    const amountToMove = moveUp - this.animPercent;\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        amountToMove = moveDown + this._arcs.length + this.animPercent;\n      }\n      else if (moveDown === 0) {\n        amountToMove = (moveDown - this.animPercent) % this._arcs.length;\n      }\n      else {\n        amountToMove = (moveDown + this.animPercent) % this._arcs.length;\n      }\n    }\n    this.autoStepSize = amountToMove / this.autoStepTotal;\n    this.autoStepCount = 0;\n    // if (this._arcs[this._arcOffset]) this._arcs[this._arcOffset].scaler = 0;\n    // this._arcOffset = newOffset;\n    // this.animPercent = 0;\n  }\n\n  updateAutoMoving () {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.animPercent += this.autoStepSize;\n      this.autoStepCount++;\n      if (this.animPercent >= 1) {\n        this._arcOffset -= this.animDirection;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset<0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.animPercent = 0;\n      }\n      else if (this.animPercent < 0) {\n        this._arcOffset += this.animDirection;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.animPercent = 1 + this.animPercent;\n      }\n    }\n    else {\n      this.isAutoMoving = false;\n      this._arcOffset = this.targetOffset;\n      this.animPercent = 0;\n    }\n  }\n\n  transpose (i) {\n    const realStart = this.arcEndPoints[i].start;\n    const realEnd = this.arcEndPoints[i].end;\n\n    let target = i + this.animDirection;\n    if (target < 0) {\n      target = this._arcs.length + target;\n    }\n    else if (target >= this._arcs.length) {\n      target = target%this._arcs.length;\n    }\n\n    let startDiff = this.arcEndPoints[target].star - realStart;\n    let endDiff = this.arcEndPoints[target].end - realEnd;\n    if (i === 0 && this.animDirection === 1) {\n      startDiff = startDiff * -1;\n      endDiff = endDiff + utils.PI2;\n    }\n    else if (i === 1 && this.animDirection === -1) {\n      startDiff = startDiff * -1;\n      endDiff = utils.PI2 + endDiff;\n    }\n\n    let currentStart = (startDiff * this.animPercent) + realStart;\n    let currentEnd = (endDiff * this.animPercent) + realEnd;\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    }\n    else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    }\n    else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n\n    const highlightCuttoff = 1 / 50;\n    if (this.animPercent >= 0 && this.animPercent < highlightCuttoff) {\n      this._highlighted = {\n        0: true,\n        1: false\n      };\n    }\n    else if (this.animPercent >= highlightCuttoff && this.animPercent < 0.5) {\n      this._highlighted = {\n        0: true,\n        1: true\n      };\n    }\n    else if (this.animPercent >= 0.5 && this.animPercent < 1 - highlightCuttoff) {\n      this._highlighted = {\n        0: true,\n        1: true\n      };\n    }\n    else if (this.animPercent >= 1 - highlightCuttoff && this.animPercent < 1) {\n      this._highlighted = {\n        0: false,\n        1: true\n      };\n    }\n    return [currentStart, currentEnd];\n  }\n\n  mouseEvent (mouseX, mouseY, compRadian) {\n    for (const i in this._highlighted) {\n      if (this._highlighted[i]) {\n        const arcIndex = (i + this._arcOffset) % this._arcs.length;\n        let scaler = this.animPercent * 1.25;\n        if (i === 0) {\n          scaler = 1 - scaler;\n        }\n        if (this._arcs[arcIndex].isTouchingPort(mouseX, mouseY, scaler)) {\n          this._touched = false;\n          return;\n        }\n      }\n    }\n    this._touched = true;\n    // see which arc was touched\n    for (const n = 0; n < this._arcs.length; n++) {\n      if (n === this._arcOffset && this._type === this.params.inType) {\n        compRadian += utils.PI2;\n      }\n      if (compRadian > this._arcs[n].start && compRadian < this._arcs[n].end) {\n        this._arcs[n].touched = true;\n        break;\n      }\n    }\n  }\n\n  rotateDrag () {\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = (utils.PI - (this._radiansMoved % utils.PI)) * -1;\n    }\n    if (this._radiansMoved <- utils.PI / 2) {\n      this._radiansMoved = (utils.PI - (Math.abs(this._radiansMoved) % utils.PI));\n    }\n    if (!this.touched) {\n      this._radiansMoved *= this.rotateFeedback;\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - (relativeMovement % 1);\n    }\n    else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + (relativeMovement % 1);\n    }\n    if (relativeMovement && relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      }\n      else {\n        this.direction = 1;\n      }\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.animPercent -= animStep;\n\n      if (this.animPercent >= 1) {\n        this._arcOffset -= this.animDirection;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.animPercent = 0;\n      }\n      else if (this.animPercent < 0) {\n        this._arcOffset += this.animDirection;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.animPercent = 1 + this.animPercent;\n      }\n    }\n  }\n\n  addArc (name, color, id) {\n    const tempArc = new Arc(\n      this.params,\n      this,\n      this._type,\n      color,\n      name,\n      id,\n      this._arcs.length\n    );\n    this._arcs.push(tempArc);\n    this.updateDimensionStuff();\n  }\n\n  deleteArc (id) {\n    for (const i = 0; i < this._arcs.length; i++) {\n      if (this._arcs[i].id === id) {\n        this._arcs.splice(i, 1);\n        break;\n      }\n    }\n    if (this._arcOffset >= this._arcs.length && this._arcOffset > 0) {\n      this._arcOffset = this._arcs.length - 1;\n    }\n    this.updateDimensionStuff();\n  }\n\n  updateDimensionStuff () {\n    this.arcEndPoints = [];\n    if (this._arcs.length === 1) {\n      this.arcEndPoints = [\n        {\n          'start': utils.PI / 2,\n          'end': utils.PI / 2\n        }\n      ];\n    }\n    else if (this._arcs.length === 2) {\n      this.arcEndPoints = [\n        {\n          'start': utils.PI,\n          'end': utils.PI2\n        },\n        {\n          'start': 0,\n          'end': utils.PI\n        },\n      ];\n    }\n    else{\n      this.arcEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n      for (const i = 1; i < this._arcs.length; i++) {\n        this.arcEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  isCloseTo (x, y) {\n    const distFromCenter = utils.getDistance(this._centerX, this._centerY, x, y);\n    const w = this._lineWidth * circleDefaults.isCloseToScaler;\n    const outerRad = (this._radiusPercentage * this.params.scaler) + w;\n    const innerRad = (this._radiusPercentage * this.params.scaler) - w;\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n    return false;\n  }\n\n  tapEvent () {\n    if (this._touched) {\n      for (const i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered () {\n    this._touched = false;\n    for (const i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n      for (const n = 0; n < this._arcs[i].ports.length; n++) {\n        this._arcs[i].ports[n].touched = false;\n        this._arcs[i].ports[n].hovered = false;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}