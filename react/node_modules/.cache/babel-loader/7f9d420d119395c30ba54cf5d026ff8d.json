{"ast":null,"code":"import * as utils from './DrawUtils';\nimport { Connection } from './Connection';\nconst fingerDefaults = {\n  portHoverDistanceThresh: 0.75\n};\n\nclass Finger {\n  constructor(params) {\n    this.params = params;\n    this.x = undefined;\n    this.y = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n    this.topSide = false;\n    this.justErased = false;\n  }\n\n  update() {\n    if (this.down || this.params.touchedPort) {\n      this.findHover();\n    }\n\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n\n      if (this.params.outCircle.touched) {\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      } else if (this.params.inCircle.touched) {\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover(mouseX, mouseY) {\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort.hovered = false;\n      this.params.hoveredPort = undefined;\n    }\n\n    const outCircle = this.params.outCircle;\n    const inCircle = this.params.inCircle;\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n\n    if (outCircle.touched || inCircle.touched) {\n      return;\n    }\n\n    if (outCircle.arcs.length > 0) {\n      if (touchedPort && touchedPort.type === this.params.inType || !touchedPort) {\n        for (let i = 0; i < 2; i++) {\n          if (hoveredPort || !outCircle.highlighted[String(i)]) {\n            continue;\n          }\n\n          const index = (i + outCircle.arcOffset) % outCircle.arcs.length;\n          const len = outCircle.arcs[index].ports.length;\n\n          for (let n = 0; n < len; n++) {\n            const port = outCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouseX, mouseY);\n\n            if (absDiff < port.size * fingerDefaults.portHoverDistanceThresh) {\n              this.params.outCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.outCircle.arcs[index].ports[n];\n              break;\n            } else {\n              this.params.outCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (this.params.hoveredPort || this.params.inCircle.arcs.length <= 0) {\n      return;\n    }\n\n    if (!this.params.touchedPoint || this.params.touchedPort.type === this.params.outType) {\n      //loop through inner seen ports\n      for (var i = 0; i < 2; i++) {\n        if (!hoveredPort && inCircle.highlighted[String(i)]) {\n          var index = (i + inCircle.arcOffset) % inCircle.arcs.length;\n          var len = inCircle.arcs[index].ports.length;\n\n          for (var n = 0; n < len; n++) {\n            const port = this.params.inCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouseX, mouseY);\n\n            if (absDiff < port.size / 2) {\n              this.params.inCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.inCircle.arcs[index].ports[n];\n              break;\n            } else {\n              this.params.inCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  touchEvent() {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n\n    if (this.params.inCircle.isCloseTo(this.x, this.y)) {\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    } else if (this.params.outCircle.isCloseTo(this.x, this.y)) {\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection() {\n    for (let i in this.params.connections) {\n      const conn = this.params.connections[i];\n\n      if (conn.hovered) {\n        const tempDist = utils.getDistance(this.x, this.y, conn.deleteX, conn.deleteY);\n\n        if (tempDist < conn.deleteSize) {\n          const receiveID = conn.outPort.parent.id;\n          const routeID = conn.inPort.parent.id;\n          const inportIndex = conn.inPort.index;\n          this.params.sendRoute(receiveID, routeID, inportIndex, this.params.deleteType);\n          this.justErased = true;\n\n          if (this.params.testingGUI) {\n            delete this.params.connections[i];\n          }\n\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  resetFromNewCoords(x, y) {\n    if (this.x && this.y) {\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease() {\n    this.down = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  tapEvent(x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent(); // reset some Finger variables\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    this.justErased = false; // find which Connection is being interacted with\n\n    const touchedPort = this.params.touchedPort;\n\n    if (touchedPort) {\n      // set all to hovered to false\n      for (let n in this.params.connections) {\n        this.params.connections[n].hovered = false;\n      } // then, find the interactive connection\n\n\n      for (let n in this.params.connections) {\n        if (this.params.connections[n].inPort === touchedPort) {\n          this.params.connections[n].hovered = true;\n        } else if (this.params.connections[n].outPort === touchedPort) {\n          this.params.connections[n].hovered = true;\n        }\n      }\n    }\n\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  releaseEvent(x, y) {\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n\n    if (touchedPort && hoveredPort && hoveredPort !== touchedPort) {\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n\n    for (var n in this.params.connections) {\n      this.params.connections[n].hovered = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  makeConnection(port1, port2) {\n    let inPort;\n    let outPort;\n\n    if (port1.type === this.params.inType) {\n      inPort = port1;\n      outPort = port2;\n    } else {\n      inPort = port2;\n      outPort = port1;\n    }\n\n    const tempName = Connection.generateName(inPort, outPort);\n\n    if (!this.params.connections[tempName]) {\n      const receiverID = outPort.parent.id;\n      const senderID = inPort.parent.id;\n      this.params.sendRoute(receiverID, senderID, inPort.index, outPort.index);\n    }\n  }\n\n  dragEvent(x, y, initRadians) {\n    this.resetFromNewCoords(x, y); // determine what side of the screen we're on\n\n    if (this.y > this.params.middleY) this.topSide = true;else this.topSide = false;\n\n    if (!initRadians) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n\n    if (initRadians) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian(type) {\n    return type === this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter(x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n\n    if (type === this.params.inType) {\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n\n    if (x > middleX) {\n      if (y > middleY) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < middleY) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < middleX) {\n      if (y > middleY) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < middleY) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > middleY) {\n        return Math.PI * 0.5;\n      } else if (y < middleY) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}\n\nexport { Finger };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","Connection","fingerDefaults","portHoverDistanceThresh","Finger","constructor","params","x","undefined","y","xDiff","yDiff","down","inRadianDiff","inRadianPrev","inRadianNew","outRadianDiff","outRadianPrev","outRadianNew","topSide","justErased","update","touchedPort","findHover","outCircle","arcs","length","in_radianDiff","out_radianDiff","touched","radiansMoved","inCircle","mouseX","mouseY","hoveredPort","hovered","type","inType","i","highlighted","String","index","arcOffset","len","ports","n","port","absDiff","getDistance","size","touchedPoint","outType","touchEvent","handleDeleteConnection","isCloseTo","mouseEvent","connections","conn","tempDist","deleteX","deleteY","deleteSize","receiveID","outPort","parent","id","routeID","inPort","inportIndex","sendRoute","deleteType","testingGUI","resetFromNewCoords","resetOnRelease","radianDown","radianDiff","tapEvent","releaseEvent","makeConnection","clearCirclesTouchedHovered","port1","port2","tempName","generateName","receiverID","senderID","dragEvent","initRadians","middleY","radiansFromCenter","getRadian","middleX","centerX","centerY","yDist","Math","abs","xDist","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { Connection } from './Connection'\n\nconst fingerDefaults = {\n  portHoverDistanceThresh: 0.75\n};\n\n\nclass Finger {\n  constructor (params) {\n    this.params = params;\n\n    this.x = undefined;\n    this.y = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n\n    this.topSide = false;\n    this.justErased = false;\n  }\n\n  update () {\n    if (this.down || this.params.touchedPort) {\n      this.findHover();\n    }\n    if (this.down && this.params.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n      if(this.params.outCircle.touched){\n        this.params.outCircle.radiansMoved = out_radianDiff;\n      }\n      else if(this.params.inCircle.touched){\n        this.params.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover (mouseX, mouseY) {\n    if (this.params.hoveredPort) {\n      this.params.hoveredPort.hovered = false;\n      this.params.hoveredPort = undefined;\n    }\n    const outCircle = this.params.outCircle;\n    const inCircle = this.params.inCircle;\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n    if (outCircle.touched || inCircle.touched) {\n      return;\n    }\n    if (outCircle.arcs.length > 0) {\n      if ((touchedPort && touchedPort.type === this.params.inType) || !touchedPort) {\n        for (let i = 0; i < 2; i++) {\n          if (hoveredPort || !outCircle.highlighted[String(i)]) {\n            continue;\n          }\n          const index = (i + outCircle.arcOffset) % outCircle.arcs.length;\n          const len = outCircle.arcs[index].ports.length;\n          for (let n = 0; n < len; n++) {\n            const port = outCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouseX, mouseY);\n            if (absDiff < port.size * fingerDefaults.portHoverDistanceThresh) {\n              this.params.outCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.outCircle.arcs[index].ports[n];\n              break;\n            }\n            else {\n              this.params.outCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n    if (this.params.hoveredPort || this.params.inCircle.arcs.length <= 0) {\n      return;\n    }\n    if (!this.params.touchedPoint || this.params.touchedPort.type === this.params.outType) {\n      //loop through inner seen ports\n      for (var i = 0; i < 2; i++) {\n        if (!hoveredPort && inCircle.highlighted[String(i)]) {\n          var index = (i + inCircle.arcOffset) % inCircle.arcs.length;\n          var len = inCircle.arcs[index].ports.length;\n          for (var n = 0; n < len; n++) {\n            const port = this.params.inCircle.arcs[index].ports[n];\n            const absDiff = utils.getDistance(port.x, port.y, mouseX, mouseY);\n            if (absDiff < port.size / 2) {\n              this.params.inCircle.arcs[index].ports[n].hovered = true;\n              this.params.hoveredPort = this.params.inCircle.arcs[index].ports[n];\n              break;\n            }\n            else {\n              this.params.inCircle.arcs[index].ports[n].hovered = false;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  touchEvent () {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n    if(this.params.inCircle.isCloseTo(this.x, this.y)){\n      this.params.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    }\n    else if(this.params.outCircle.isCloseTo(this.x, this.y)){\n      this.params.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n  }\n\n  handleDeleteConnection () {\n    for(let i in this.params.connections){\n      const conn = this.params.connections[i];\n      if(conn.hovered){\n        const tempDist = utils.getDistance(\n          this.x, this.y, conn.deleteX, conn.deleteY);\n        if(tempDist < conn.deleteSize){\n          const receiveID = conn.outPort.parent.id;\n          const routeID = conn.inPort.parent.id;\n          const inportIndex = conn.inPort.index;\n          this.params.sendRoute(\n            receiveID, routeID, inportIndex, this.params.deleteType);\n          this.justErased = true;\n          if (this.params.testingGUI) {\n            delete this.params.connections[i];\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  resetFromNewCoords (x, y) {\n    if(this.x && this.y){\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease () {\n    this.down = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  tapEvent (x, y) {\n    this.params.inCircle.tapEvent();\n    this.params.outCircle.tapEvent();\n\n    // reset some Finger variables\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    this.justErased = false;\n    // find which Connection is being interacted with\n    const touchedPort = this.params.touchedPort;\n    if(touchedPort){\n      // set all to hovered to false\n      for(let n in this.params.connections){\n        this.params.connections[n].hovered = false;\n      }\n      // then, find the interactive connection\n      for (let n in this.params.connections){\n        if (this.params.connections[n].inPort === touchedPort){\n          this.params.connections[n].hovered = true;\n        }\n        else if (this.params.connections[n].outPort === touchedPort){\n          this.params.connections[n].hovered = true;\n        }\n      }\n    }\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n  }\n\n  releaseEvent (x, y) {\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.params.touchedPort;\n    const hoveredPort = this.params.hoveredPort;\n    if (touchedPort && hoveredPort && hoveredPort !== touchedPort){\n      this.makeConnection(hoveredPort,touchedPort);\n    }\n    this.params.touchedPort = undefined;\n    this.params.hoveredPort = undefined;\n\n    for (var n in this.params.connections){\n      this.params.connections[n].hovered = false;\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  makeConnection (port1, port2) {\n    let inPort;\n    let outPort;\n    if (port1.type === this.params.inType){\n      inPort = port1;\n      outPort = port2;\n    }\n    else{\n      inPort = port2;\n      outPort = port1;\n    }\n    const tempName = Connection.generateName(inPort, outPort);\n    if (!this.params.connections[tempName]){\n      const receiverID = outPort.parent.id;\n      const senderID = inPort.parent.id;\n      this.params.sendRoute(receiverID, senderID, inPort.index, outPort.index);\n    }\n  }\n\n  dragEvent (x, y, initRadians) {\n    this.resetFromNewCoords(x, y);\n    // determine what side of the screen we're on\n    if (this.y > this.params.middleY) this.topSide = true;\n    else this.topSide = false;\n    if (!initRadians){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, this.params.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, this.params.outType);\n    if  (initRadians){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian (type) {\n    return type === this.params.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter (x, y, type) {\n    let middleX = this.params.outCircle.centerX;\n    let middleY = this.params.outCircle.centerY;\n    if (type === this.params.inType){\n      middleX = this.params.inCircle.centerX;\n      middleY = this.params.inCircle.centerY;\n    }\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    if (x > middleX){\n      if (y > middleY){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < middleY){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < middleX){\n      if (y > middleY){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < middleY){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > middleY){\n        return Math.PI * 0.5;\n      }\n      else if (y < middleY){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n\nexport { Finger }\n"]},"metadata":{},"sourceType":"module"}