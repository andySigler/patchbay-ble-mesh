{"ast":null,"code":"import * as utils from './PatchbayUtils';\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3\n};\n\nclass Finger {\n  constructor(inCircle, outCircle, connections, onMakeConnection, onDeleteConnection, getGlobalTouchedPort, getGlobalHoveredPort, setGlobalTouchedPort, setGlobalHoveredPort) {\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n    this.getGlobalTouchedPort = getGlobalTouchedPort;\n    this.getGlobalHoveredPort = getGlobalHoveredPort;\n    this.setGlobalTouchedPort = setGlobalTouchedPort;\n    this.setGlobalHoveredPort = setGlobalHoveredPort;\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n    this.didMove = false;\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n    this.justErased = false;\n  }\n\n  update() {\n    if (this.down) {\n      this.findHover();\n    }\n\n    if (this.down && this.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n\n      if (this.outCircle.touched) {\n        this.outCircle.radiansMoved = out_radianDiff;\n      } else if (this.inCircle.touched) {\n        this.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover() {\n    if (!this.getGlobalTouchedPort()) {\n      return;\n    }\n\n    if (this.getGlobalHoveredPort()) {\n      this.setGlobalHoveredPort(undefined);\n    }\n\n    this.findHoveredPort(this.outCircle);\n\n    if (this.getGlobalHoveredPort()) {\n      return;\n    }\n\n    this.findHoveredPort(this.inCircle);\n\n    if (this.getGlobalHoveredPort()) {\n      return;\n    }\n  }\n\n  findHoveredPort(circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n\n    if (this.getGlobalTouchedPort().type === circle.type) {\n      return;\n    }\n\n    for (let arc of circle.getExpandedArcs()) {\n      const totalPorts = arc.ports.length;\n\n      for (let n = 0; n < totalPorts; n++) {\n        const port = arc.ports[n];\n\n        if (port.isUserTouching(this.x, this.y)) {\n          this.setGlobalHoveredPort(port);\n          break;\n        }\n      }\n    }\n  }\n\n  touchEvent() {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n\n    if (this.handleDeleteConnection()) {\n      return;\n    } // set all connections.hovered to false\n\n\n    this.unselectAllConnections();\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n\n    if (this.inCircle.isCloseTo(this.x, this.y)) {\n      port = this.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    } else if (this.outCircle.isCloseTo(this.x, this.y)) {\n      port = this.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n\n    if (port) {\n      this.setGlobalTouchedPort(port);\n    }\n  }\n\n  handleDeleteConnection() {\n    for (let i in this.connections) {\n      const conn = this.connections[i];\n\n      if (conn.isUserTouching(this.x, this.y)) {\n        this.onDeleteConnection(conn);\n        this.justErased = true;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  resetFromNewCoords(x, y) {\n    if (this.x && this.y) {\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease() {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  unselectAllConnections() {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  releaseWithoutMoving(x, y) {\n    this.inCircle.tapEvent();\n    this.outCircle.tapEvent(); // reset some Finger variables\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease(); // set all connections.hovered to false\n\n    if (!this.justErased) {\n      this.unselectAllConnections();\n    } else {\n      this.justErased = false;\n    } // find which Connection is being interacted with\n\n\n    if (this.getGlobalTouchedPort()) {\n      // then, find the interactive connection\n      this.unselectAllConnections();\n\n      for (let name in this.connections) {\n        const conn = this.connections[name];\n\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()) {\n          conn.selected = true;\n        }\n      }\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent(x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.getGlobalTouchedPort();\n    const hoveredPort = this.getGlobalHoveredPort();\n\n    if (touchedPort && hoveredPort) {\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.unselectAllConnections();\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered() {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this.setGlobalTouchedPort(undefined);\n    this.setGlobalHoveredPort(undefined);\n  }\n\n  makeConnection(port1, port2) {\n    let inPort;\n    let outPort;\n\n    if (port1.type === utils.inType) {\n      inPort = port1;\n      outPort = port2;\n    } else {\n      inPort = port2;\n      outPort = port1;\n    }\n\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent(x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n\n    this.resetFromNewCoords(x, y);\n    this.didMove = !justTouched;\n\n    if (!justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, utils.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, utils.outType);\n\n    if (justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian(type) {\n    return type === utils.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter(x, y, type) {\n    let middleX = this.outCircle.x;\n    let middleY = this.outCircle.y;\n\n    if (type === utils.inType) {\n      middleX = this.inCircle.x;\n      middleY = this.inCircle.y;\n    }\n\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n\n    if (x > middleX) {\n      if (y > middleY) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < middleY) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < middleX) {\n      if (y > middleY) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < middleY) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > middleY) {\n        return Math.PI * 0.5;\n      } else if (y < middleY) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}\n\nexport { Finger };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","fingerDefaults","tapPixelsMovedThresh","Finger","constructor","inCircle","outCircle","connections","onMakeConnection","onDeleteConnection","getGlobalTouchedPort","getGlobalHoveredPort","setGlobalTouchedPort","setGlobalHoveredPort","x","undefined","y","xStart","yStart","xDiff","yDiff","down","didMove","inRadianDiff","inRadianPrev","inRadianNew","outRadianDiff","outRadianPrev","outRadianNew","justErased","update","findHover","arcs","length","in_radianDiff","out_radianDiff","touched","radiansMoved","findHoveredPort","circle","type","arc","getExpandedArcs","totalPorts","ports","n","port","isUserTouching","touchEvent","handleDeleteConnection","unselectAllConnections","clearTouchedHovered","isCloseTo","mouseEvent","i","conn","resetFromNewCoords","resetOnRelease","radianDown","radianDiff","name","selected","releaseWithoutMoving","tapEvent","inPort","isTouched","outPort","clearCirclesTouchedHovered","releaseEvent","getDistance","touchedPort","hoveredPort","makeConnection","port1","port2","inType","moveEvent","justTouched","radiansFromCenter","outType","getRadian","middleX","middleY","yDist","Math","abs","xDist","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './PatchbayUtils'\n\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3\n};\n\n\nclass Finger {\n  constructor (inCircle, outCircle, connections, onMakeConnection, onDeleteConnection, getGlobalTouchedPort, getGlobalHoveredPort, setGlobalTouchedPort, setGlobalHoveredPort) {\n\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n\n    this.getGlobalTouchedPort = getGlobalTouchedPort;\n    this.getGlobalHoveredPort = getGlobalHoveredPort;\n    this.setGlobalTouchedPort = setGlobalTouchedPort;\n    this.setGlobalHoveredPort = setGlobalHoveredPort;\n\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.xDiff = undefined;\n    this.yDiff = undefined;\n    this.down = false;\n    this.didMove = false;\n\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n\n    this.justErased = false;\n  }\n\n  update () {\n    if (this.down) {\n      this.findHover();\n    }\n    if (this.down && this.outCircle.arcs.length > 1) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n      if(this.outCircle.touched){\n        this.outCircle.radiansMoved = out_radianDiff;\n      }\n      else if(this.inCircle.touched){\n        this.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n    this.xDiff = 0;\n    this.yDiff = 0;\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  findHover () {\n    if (!this.getGlobalTouchedPort()) {\n      return;\n    }\n    if (this.getGlobalHoveredPort()) {\n      this.setGlobalHoveredPort(undefined);\n    }\n    this.findHoveredPort(this.outCircle);\n    if (this.getGlobalHoveredPort()) {\n      return;\n    }\n    this.findHoveredPort(this.inCircle);\n    if (this.getGlobalHoveredPort()) {\n      return;\n    }\n  }\n\n  findHoveredPort (circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n    if (this.getGlobalTouchedPort().type === circle.type) {\n      return;\n    }\n    for (let arc of circle.getExpandedArcs()) {\n      const totalPorts = arc.ports.length;\n      for (let n = 0; n < totalPorts; n++) {\n        const port = arc.ports[n];\n        if (port.isUserTouching(this.x, this.y)) {\n          this.setGlobalHoveredPort(port);\n          break;\n        }\n      }\n    }\n  }\n\n  touchEvent () {\n    this.down = true;\n    this.xDiff = 0;\n    this.yDiff = 0;\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n    // set all connections.hovered to false\n    this.unselectAllConnections();\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n    if(this.inCircle.isCloseTo(this.x, this.y)){\n      port = this.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    }\n    else if(this.outCircle.isCloseTo(this.x, this.y)){\n      port = this.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n    if (port) {\n      this.setGlobalTouchedPort(port);\n    }\n  }\n\n  handleDeleteConnection () {\n    for(let i in this.connections){\n      const conn = this.connections[i];\n      if (conn.isUserTouching(this.x, this.y)) {\n        this.onDeleteConnection(conn);\n        this.justErased = true;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  resetFromNewCoords (x, y) {\n    if(this.x && this.y){\n      this.xDiff = x - this.x;\n      this.yDiff = y - this.y;\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  resetOnRelease () {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  unselectAllConnections () {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  releaseWithoutMoving (x, y) {\n    this.inCircle.tapEvent();\n    this.outCircle.tapEvent();\n    // reset some Finger variables\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    // set all connections.hovered to false\n    if (!this.justErased) {\n      this.unselectAllConnections();\n    }\n    else {\n      this.justErased = false;\n    }\n    // find which Connection is being interacted with\n    if(this.getGlobalTouchedPort()){\n      // then, find the interactive connection\n      this.unselectAllConnections();\n      for (let name in this.connections){\n        const conn = this.connections[name];\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()){\n          conn.selected = true;\n        }\n      }\n    }\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent (x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n    this.resetFromNewCoords(x, y);\n    this.resetOnRelease();\n    const touchedPort = this.getGlobalTouchedPort();\n    const hoveredPort = this.getGlobalHoveredPort();\n    if (touchedPort && hoveredPort){\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.unselectAllConnections();\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered () {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this.setGlobalTouchedPort(undefined);\n    this.setGlobalHoveredPort(undefined);\n  }\n\n  makeConnection (port1, port2) {\n    let inPort;\n    let outPort;\n    if (port1.type === utils.inType){\n      inPort = port1;\n      outPort = port2;\n    }\n    else{\n      inPort = port2;\n      outPort = port1;\n    }\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent (x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n    this.resetFromNewCoords(x, y);\n    this.didMove = !justTouched;\n    if (!justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, utils.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, utils.outType);\n    if (justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian (type) {\n    return type === utils.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter (x, y, type) {\n    let middleX = this.outCircle.x;\n    let middleY = this.outCircle.y;\n    if (type === utils.inType){\n      middleX = this.inCircle.x;\n      middleY = this.inCircle.y;\n    }\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    if (x > middleX){\n      if (y > middleY){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < middleY){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < middleX){\n      if (y > middleY){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < middleY){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > middleY){\n        return Math.PI * 0.5;\n      }\n      else if (y < middleY){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n\nexport { Finger }\n"]},"metadata":{},"sourceType":"module"}