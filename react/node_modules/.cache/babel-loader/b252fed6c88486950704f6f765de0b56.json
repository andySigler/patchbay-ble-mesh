{"ast":null,"code":"import * as utils from './DrawUtils';\nimport { AppParams } from './AppParams';\nimport { Connection } from './Connection';\nimport { Finger } from './Finger';\nimport { Circle } from './Circle';\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25\n};\n\nclass Patchbay {\n  constructor(context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(this.params.inType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.params.outCircle = new Circle(this.params.outType, patchbayDefaults.screenPercentage, patchbayDefaults.tempThickness);\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop() {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n\n    this.clearCanvas();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  drawTouchedPort() {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const circleScaler = Math.max(Math.min(this.params.touchedPort.scaler * 1.25, 1), 0);\n    const circleRadius = touchedPort.size * scaler * 0.1; // draw the outlining circle\n\n    this.params.context.save();\n    this.params.context.lineWidth = this.params.touchedPort.size * 0.1;\n    this.params.context.strokeStyle = 'white';\n    this.params.context.beginPath();\n    this.params.context.arc(touchedPort.x, touchedPort.y, this.params.touchedPort.size, 0, Math.PI * 2, false);\n    this.params.context.stroke();\n    this.params.context.restore(); // then draw the line\n\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter) * 2;\n    touchedLineWidth += Math.max(this.params.touchedPort.size * 0.05, 2);\n    this.params.context.save();\n    this.params.context.lineWidth = touchedLineWidth;\n    this.params.context.strokeStyle = utils.colors.green();\n    this.params.context.beginPath();\n    this.params.context.moveTo(touchedPort.x, touchedPort.y);\n    this.params.context.lineTo(mouse.x, mouse.y);\n    this.params.context.stroke();\n    this.params.context.restore();\n    this.params.context.save();\n    this.params.context.fillStyle = utils.colors.white();\n    this.params.context.beginPath();\n    this.params.context.arc(touchedPort.x, touchedPort.y, circleRadius, 0, utils.PI2, false);\n    this.params.context.fill();\n    this.params.context.restore();\n  }\n\n  setSize(width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection(outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(outputID, outputIndex, inputID, inputIndex);\n\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    } else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n\n    return tempName;\n  }\n\n  eraseNodeFromConnections(id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n\n}\n\nexport { Patchbay };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Patchbay.js"],"names":["utils","AppParams","Connection","Finger","Circle","patchbayDefaults","tempThickness","screenPercentage","Patchbay","constructor","context","params","inCircle","inType","outCircle","outType","finger","reqAnimFrame","undefined","drawLoop","cancelAnimationFrame","clearCanvas","requestAnimationFrame","drawTouchedPort","touchedPort","circleScaler","Math","max","min","scaler","circleRadius","size","save","lineWidth","strokeStyle","beginPath","arc","x","y","PI","stroke","restore","touchedLineWidth","sin","wobbleCounter","colors","green","moveTo","lineTo","mouse","fillStyle","white","PI2","fill","setSize","width","height","grey","fillRect","createConnection","outputID","inputID","inputIndex","outputIndex","tempName","generateName","connections","outPort","getPort","inPort","newConnection","addConnection","exists","eraseNodeFromConnections","id","n","conn","parent","deleteConnection"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { AppParams } from './AppParams'\nimport { Connection } from './Connection'\nimport { Finger } from './Finger'\nimport { Circle } from './Circle'\n\n\nconst patchbayDefaults = {\n  tempThickness: 0.1,\n  screenPercentage: 0.25\n};\n\nclass Patchbay {\n  constructor (context) {\n    this.params = new AppParams(context);\n    this.params.inCircle = new Circle(\n      this.params.inType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.params.outCircle = new Circle(\n      this.params.outType,\n      patchbayDefaults.screenPercentage,\n      patchbayDefaults.tempThickness\n    );\n    this.finger = new Finger(this.params);\n    this.reqAnimFrame = undefined;\n  }\n\n  drawLoop () {\n    if (this.reqAnimFrame) {\n      cancelAnimationFrame(this.reqAnimFrame);\n      this.reqAnimFrame = undefined;\n    }\n    this.clearCanvas();\n    this.reqAnimFrame = requestAnimationFrame(() => this.drawLoop);\n  }\n\n  drawTouchedPort () {\n    if (!this.params.touchedPort) {\n      return;\n    }\n\n    const circleScaler = Math.max(Math.min(this.params.touchedPort.scaler * 1.25, 1), 0);\n    const circleRadius = touchedPort.size * scaler * 0.1;\n\n    // draw the outlining circle\n    this.params.context.save();\n    this.params.context.lineWidth = this.params.touchedPort.size * 0.1;\n    this.params.context.strokeStyle = 'white';\n    this.params.context.beginPath();\n    this.params.context.arc(\n      touchedPort.x,\n      touchedPort.y,\n      this.params.touchedPort.size,\n      0,\n      Math.PI*2,\n      false\n    );\n    this.params.context.stroke();\n    this.params.context.restore();\n\n    // then draw the line\n    let touchedLineWidth = Math.sin(this.params.touchedPort.wobbleCounter) * 2;\n    touchedLineWidth += Math.max(this.params.touchedPort.size * 0.05, 2);\n    this.params.context.save();\n    this.params.context.lineWidth = touchedLineWidth;\n    this.params.context.strokeStyle = utils.colors.green();\n    this.params.context.beginPath();\n    this.params.context.moveTo(touchedPort.x,touchedPort.y);\n    this.params.context.lineTo(mouse.x,mouse.y);\n    this.params.context.stroke();\n    this.params.context.restore();\n\n    this.params.context.save();\n    this.params.context.fillStyle = utils.colors.white();\n    this.params.context.beginPath();\n    this.params.context.arc(\n      touchedPort.x,\n      touchedPort.y,\n      circleRadius,\n      0,\n      utils.PI2,\n      false\n    );\n    this.params.context.fill();\n    this.params.context.restore();\n  }\n\n  setSize (width, height) {\n    this.params.width = width;\n    this.params.height = height;\n  }\n\n  clearCanvas() {\n    this.params.context.fillStyle = utils.colors.grey();\n    this.params.context.fillRect(0, 0, this.params.width, this.params.height);\n  }\n\n  createConnection (outputID, inputID, inputIndex, outputIndex) {\n    const tempName = Connection.generateName(\n      outputID, outputIndex, inputID, inputIndex);\n    if (!this.params.connections[tempName]) {\n      let outPort = this.params.getPort(outputID, outputIndex, this.params.outType);\n      let inPort = this.params.getPort(inputID, inputIndex, this.params.inType);\n      if (outPort && inPort) {\n        const newConnection = new Connection(this.params, outPort, inPort, tempName);\n        this.params.addConnection(tempName, newConnection);\n      }\n    }\n    else {\n      // TODO: not sure what this does, seems to be left over from thesis\n      this.params.connections[tempName].exists = true;\n    }\n    return tempName;\n  }\n\n  eraseNodeFromConnections (id) {\n    for (let n in this.params.connections) {\n      const conn = this.params.connections[n];\n      if (conn.outPort.parent.id === id || conn.inPort.parent.id === id) {\n        this.params.deleteConnection(n);\n      }\n    }\n  }\n}\n\nexport { Patchbay }\n"]},"metadata":{},"sourceType":"module"}