{"ast":null,"code":"import * as utils from './PatchbayUtils';\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3,\n  touchCircleRadiusScaler: 0.1,\n  touchCircleThicknessScaler: 0.01,\n  touchedLineWidth: 3\n};\n\nclass Finger {\n  constructor(context, inCircle, outCircle, connections, onMakeConnection, onDeleteConnection) {\n    this.context = context;\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n    this.circleRadius = undefined;\n    this.circleThickness = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.down = false;\n    this.didMove = false;\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n    this.justErased = false;\n  }\n\n  get touchedPort() {\n    return this._touchedPort;\n  }\n\n  get hoveredPort() {\n    return this._hoveredPort;\n  }\n\n  adjustToScreenSize(screenSize) {\n    this.circleRadius = screenSize * fingerDefaults.touchCircleRadiusScaler;\n    this.circleThickness = screenSize * fingerDefaults.touchCircleThicknessScaler;\n  }\n\n  update() {\n    if (this.down && this._touchedPort) {\n      this.findHover();\n    }\n\n    if (!this._touchedPort) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n\n      if (this.outCircle.touched) {\n        this.outCircle.radiansMoved = out_radianDiff;\n      } else if (this.inCircle.touched) {\n        this.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  draw() {\n    if (this.touchedPort) {\n      this.drawTouchLine();\n      this.drawTouchedPort();\n\n      if (this.hoveredPort) {\n        this.drawHoveredPort();\n      }\n    }\n  }\n\n  drawTouchedPort() {\n    this.context.save();\n    utils.drawCircle(this.context, this.touchedPort.x, this.touchedPort.y, this.circleRadius, this.circleThickness, utils.colors.highlight(), undefined);\n    this.context.restore();\n  }\n\n  drawTouchLine() {\n    this.context.save();\n    utils.drawLine(this.context, this.touchedPort.x, this.touchedPort.y, this.x, this.y, fingerDefaults.touchedLineWidth, utils.colors.highlight());\n    this.context.restore(); // then two smaller filled in circles to cover the tips of the line\n\n    this.context.save();\n    utils.drawCircle(this.context, this.touchedPort.x, this.touchedPort.y, fingerDefaults.touchedLineWidth, 0, undefined, utils.colors.highlight());\n    utils.drawCircle(this.context, this.x, this.y, fingerDefaults.touchedLineWidth, 0, undefined, utils.colors.highlight());\n    this.context.restore();\n  }\n\n  drawHoveredPort() {\n    this.context.save();\n    utils.drawCircle(this.context, this.hoveredPort.x, this.hoveredPort.y, this.circleRadius, this.circleThickness, utils.colors.highlight(), undefined);\n    this.context.restore();\n  }\n\n  findHover() {\n    if (!this._touchedPort) {\n      return;\n    }\n\n    if (this._hoveredPort) {\n      this._hoveredPort = undefined;\n    }\n\n    this._hoveredPort = this.findHoveredPort(this.outCircle);\n\n    if (this._hoveredPort) {\n      return;\n    }\n\n    this._hoveredPort = this.findHoveredPort(this.inCircle);\n\n    if (this._hoveredPort) {\n      return;\n    }\n  }\n\n  findHoveredPort(circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n\n    if (this._touchedPort.type === circle.type) {\n      return;\n    }\n\n    for (let arc of circle.getExpandedArcs()) {\n      for (let port of arc.ports) {\n        if (port.isUserTouching(this.x, this.y)) {\n          return port;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  touchEvent() {\n    this.down = true;\n\n    if (this.handleDeleteConnection()) {\n      return;\n    } // set all connections.hovered to false\n\n\n    this.unselectAllConnections();\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n\n    if (this.inCircle.isCloseTo(this.x, this.y)) {\n      port = this.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    } else if (this.outCircle.isCloseTo(this.x, this.y)) {\n      port = this.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n\n    if (port) {\n      this._touchedPort = port;\n    }\n  }\n\n  handleDeleteConnection() {\n    for (let i in this.connections) {\n      const conn = this.connections[i];\n\n      if (conn.isUserTouching(this.x, this.y)) {\n        this.onDeleteConnection(conn);\n        this.justErased = true;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  resetOnRelease() {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  unselectAllConnections() {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  releaseWithoutMoving(x, y) {\n    this.inCircle.tapEvent();\n    this.outCircle.tapEvent(); // reset some Finger variables\n\n    this.x = x;\n    this.y = y;\n    this.resetOnRelease(); // set all connections.hovered to false\n\n    if (!this.justErased) {\n      this.unselectAllConnections();\n    } else {\n      this.justErased = false;\n    } // find which Connection is being interacted with\n\n\n    if (this._touchedPort) {\n      // then, find the interactive connection\n      this.unselectAllConnections();\n\n      for (let name in this.connections) {\n        const conn = this.connections[name];\n\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()) {\n          conn.selected = true;\n        }\n      }\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent(x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.resetOnRelease();\n    const touchedPort = this._touchedPort;\n    const hoveredPort = this._hoveredPort;\n\n    if (touchedPort && hoveredPort) {\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.unselectAllConnections();\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered() {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n  }\n\n  makeConnection(port1, port2) {\n    let inPort;\n    let outPort;\n\n    if (port1.type === utils.inType) {\n      inPort = port1;\n      outPort = port2;\n    } else {\n      inPort = port2;\n      outPort = port1;\n    }\n\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent(x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.didMove = !justTouched;\n\n    if (!justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, utils.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, utils.outType);\n\n    if (justTouched) {\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian(type) {\n    return type === utils.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter(x, y, type) {\n    let middleX = this.outCircle.x;\n    let middleY = this.outCircle.y;\n\n    if (type === utils.inType) {\n      middleX = this.inCircle.x;\n      middleY = this.inCircle.y;\n    }\n\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n\n    if (x > middleX) {\n      if (y > middleY) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < middleY) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < middleX) {\n      if (y > middleY) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < middleY) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > middleY) {\n        return Math.PI * 0.5;\n      } else if (y < middleY) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}\n\nexport { Finger };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","fingerDefaults","tapPixelsMovedThresh","touchCircleRadiusScaler","touchCircleThicknessScaler","touchedLineWidth","Finger","constructor","context","inCircle","outCircle","connections","onMakeConnection","onDeleteConnection","_touchedPort","undefined","_hoveredPort","circleRadius","circleThickness","x","y","xStart","yStart","down","didMove","inRadianDiff","inRadianPrev","inRadianNew","outRadianDiff","outRadianPrev","outRadianNew","justErased","touchedPort","hoveredPort","adjustToScreenSize","screenSize","update","findHover","in_radianDiff","out_radianDiff","touched","radiansMoved","draw","drawTouchLine","drawTouchedPort","drawHoveredPort","save","drawCircle","colors","highlight","restore","drawLine","findHoveredPort","circle","arcs","length","type","arc","getExpandedArcs","port","ports","isUserTouching","touchEvent","handleDeleteConnection","unselectAllConnections","clearTouchedHovered","isCloseTo","mouseEvent","i","conn","resetOnRelease","radianDown","radianDiff","name","selected","releaseWithoutMoving","tapEvent","inPort","isTouched","outPort","clearCirclesTouchedHovered","releaseEvent","getDistance","makeConnection","port1","port2","inType","moveEvent","justTouched","radiansFromCenter","outType","getRadian","middleX","middleY","yDist","Math","abs","xDist","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './PatchbayUtils'\n\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3,\n  touchCircleRadiusScaler: 0.1,\n  touchCircleThicknessScaler: 0.01,\n  touchedLineWidth: 3\n};\n\nclass Finger {\n  constructor (context, inCircle, outCircle, connections, onMakeConnection, onDeleteConnection) {\n    this.context = context;\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n\n    this.circleRadius = undefined;\n    this.circleThickness = undefined;\n\n    this.x = undefined;\n    this.y = undefined;\n    this.xStart = undefined;\n    this.yStart = undefined;\n    this.down = false;\n    this.didMove = false;\n\n    this.inRadianDiff = undefined;\n    this.inRadianPrev = undefined;\n    this.inRadianNew = undefined;\n    this.outRadianDiff = undefined;\n    this.outRadianPrev = undefined;\n    this.outRadianNew = undefined;\n\n    this.justErased = false;\n  }\n\n  get touchedPort () { return this._touchedPort; }\n\n  get hoveredPort () { return this._hoveredPort; }\n\n  adjustToScreenSize (screenSize) {\n    this.circleRadius = screenSize * fingerDefaults.touchCircleRadiusScaler;\n    this.circleThickness = screenSize * fingerDefaults.touchCircleThicknessScaler;\n  }\n\n  update () {\n    if (this.down && this._touchedPort) {\n      this.findHover();\n    }\n    if (!this._touchedPort) {\n      const in_radianDiff = this.inRadianNew - this.inRadianPrev;\n      const out_radianDiff = this.outRadianNew - this.outRadianPrev;\n      if(this.outCircle.touched){\n        this.outCircle.radiansMoved = out_radianDiff;\n      }\n      else if(this.inCircle.touched){\n        this.inCircle.radiansMoved = in_radianDiff;\n      }\n    }\n    this.inRadianPrev = this.inRadianNew;\n    this.outRadianPrev = this.outRadianNew;\n  }\n\n  draw () {\n    if (this.touchedPort) {\n      this.drawTouchLine();\n      this.drawTouchedPort();\n      if (this.hoveredPort) {\n        this.drawHoveredPort();\n      }\n    }\n  }\n\n  drawTouchedPort () {\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      this.circleRadius, this.circleThickness,\n      utils.colors.highlight(), undefined\n    );\n    this.context.restore();\n  }\n\n  drawTouchLine () {\n    this.context.save();\n    utils.drawLine(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      this.x, this.y,\n      fingerDefaults.touchedLineWidth, utils.colors.highlight()\n    );\n    this.context.restore();\n    // then two smaller filled in circles to cover the tips of the line\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      fingerDefaults.touchedLineWidth, 0,\n      undefined, utils.colors.highlight()\n    );\n    utils.drawCircle(\n      this.context,\n      this.x, this.y,\n      fingerDefaults.touchedLineWidth, 0,\n      undefined, utils.colors.highlight()\n    );\n    this.context.restore();\n  }\n\n  drawHoveredPort () {\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.hoveredPort.x, this.hoveredPort.y,\n      this.circleRadius, this.circleThickness,\n      utils.colors.highlight(), undefined\n    );\n    this.context.restore();\n  }\n\n  findHover () {\n    if (!this._touchedPort) {\n      return;\n    }\n    if (this._hoveredPort) {\n      this._hoveredPort = undefined;\n    }\n    this._hoveredPort = this.findHoveredPort(this.outCircle);\n    if (this._hoveredPort) {\n      return;\n    }\n    this._hoveredPort = this.findHoveredPort(this.inCircle);\n    if (this._hoveredPort) {\n      return;\n    }\n  }\n\n  findHoveredPort (circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n    if (this._touchedPort.type === circle.type) {\n      return;\n    }\n    for (let arc of circle.getExpandedArcs()) {\n      for (let port of arc.ports) {\n        if (port.isUserTouching(this.x, this.y)) {\n          return port;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  touchEvent () {\n    this.down = true;\n    if (this.handleDeleteConnection()) {\n      return;\n    }\n    // set all connections.hovered to false\n    this.unselectAllConnections();\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n    if(this.inCircle.isCloseTo(this.x, this.y)){\n      port = this.inCircle.mouseEvent(this.x, this.y, this.inRadianNew);\n    }\n    else if(this.outCircle.isCloseTo(this.x, this.y)){\n      port = this.outCircle.mouseEvent(this.x, this.y, this.outRadianNew);\n    }\n    if (port) {\n      this._touchedPort = port;\n    }\n  }\n\n  handleDeleteConnection () {\n    for(let i in this.connections){\n      const conn = this.connections[i];\n      if (conn.isUserTouching(this.x, this.y)) {\n        this.onDeleteConnection(conn);\n        this.justErased = true;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  resetOnRelease () {\n    this.down = false;\n    this.didMove = false;\n    this.radianDown = undefined;\n    this.radianDiff = undefined;\n  }\n\n  unselectAllConnections () {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  releaseWithoutMoving (x, y) {\n    this.inCircle.tapEvent();\n    this.outCircle.tapEvent();\n    // reset some Finger variables\n    this.x = x;\n    this.y = y;\n    this.resetOnRelease();\n    // set all connections.hovered to false\n    if (!this.justErased) {\n      this.unselectAllConnections();\n    }\n    else {\n      this.justErased = false;\n    }\n    // find which Connection is being interacted with\n    if(this._touchedPort){\n      // then, find the interactive connection\n      this.unselectAllConnections();\n      for (let name in this.connections){\n        const conn = this.connections[name];\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()){\n          conn.selected = true;\n        }\n      }\n    }\n    this.clearCirclesTouchedHovered();\n  }\n\n  releaseEvent (x, y) {\n    if (!this.didMove || utils.getDistance(this.xStart, this.yStart, x, y) < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n      return;\n    }\n    this.x = x;\n    this.y = y;\n    this.resetOnRelease();\n    const touchedPort = this._touchedPort;\n    const hoveredPort = this._hoveredPort;\n    if (touchedPort && hoveredPort){\n      this.makeConnection(hoveredPort, touchedPort);\n    }\n\n    this.unselectAllConnections();\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  clearCirclesTouchedHovered () {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n  }\n\n  makeConnection (port1, port2) {\n    let inPort;\n    let outPort;\n    if (port1.type === utils.inType){\n      inPort = port1;\n      outPort = port2;\n    }\n    else{\n      inPort = port2;\n      outPort = port1;\n    }\n    this.onMakeConnection(inPort, outPort);\n  }\n\n  moveEvent (x, y, justTouched) {\n    if (justTouched) {\n      this.xStart = x;\n      this.yStart = y;\n    }\n    this.x = x;\n    this.y = y;\n    this.didMove = !justTouched;\n    if (!justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n    this.inRadianNew = this.radiansFromCenter(this.x, this.y, utils.inType);\n    this.outRadianNew = this.radiansFromCenter(this.x, this.y, utils.outType);\n    if (justTouched){\n      this.inRadianPrev = this.inRadianNew;\n      this.outRadianPrev = this.outRadianNew;\n    }\n  }\n\n  getRadian (type) {\n    return type === utils.inType ? this.inRadianNew : this.outRadianNew;\n  }\n\n  radiansFromCenter (x, y, type) {\n    let middleX = this.outCircle.x;\n    let middleY = this.outCircle.y;\n    if (type === utils.inType){\n      middleX = this.inCircle.x;\n      middleY = this.inCircle.y;\n    }\n    const yDist = Math.abs(middleY - y);\n    const xDist = Math.abs(middleX - x);\n    if (x > middleX){\n      if (y > middleY){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < middleY){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < middleX){\n      if (y > middleY){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < middleY){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > middleY){\n        return Math.PI * 0.5;\n      }\n      else if (y < middleY){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n\nexport { Finger }\n"]},"metadata":{},"sourceType":"module"}