{"ast":null,"code":"import * as utils from './PatchbayUtils';\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3,\n  touchCircleRadiusScaler: 0.1,\n  touchCircleThicknessScaler: 0.01,\n  touchedLineWidth: 3\n};\n\nclass Finger {\n  constructor(context, inCircle, outCircle, connections, onMakeConnection, onDeleteConnection) {\n    this.context = context;\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n    this.circleRadius = undefined;\n    this.circleThickness = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.touchX = undefined;\n    this.touchY = undefined;\n    this.isTouchingScreen = false;\n    this.radianNew = {};\n    this.radianNew[utils.inType] = 0;\n    this.radianNew[utils.outType] = 0;\n    this.radianPrev = Object.assign({}, this.radianNew);\n  }\n\n  get touchedPort() {\n    return this._touchedPort;\n  }\n\n  get hoveredPort() {\n    return this._hoveredPort;\n  }\n\n  adjustToScreenSize(screenSize) {\n    this.circleRadius = screenSize * fingerDefaults.touchCircleRadiusScaler;\n    this.circleThickness = screenSize * fingerDefaults.touchCircleThicknessScaler;\n  }\n\n  update() {\n    if (!this._touchedPort) {\n      if (this.inCircle.touched) {\n        this.inCircle.radiansMoved = this.radianNew[utils.inType] - this.radianPrev[utils.inType];\n      } else if (this.outCircle.touched) {\n        this.outCircle.radiansMoved = this.radianNew[utils.outType] - this.radianPrev[utils.outType];\n      }\n    }\n\n    this.radianPrev = Object.assign({}, this.radianNew);\n  }\n\n  touchEvent(x, y) {\n    this.touchX = x;\n    this.touchY = y;\n    this.isTouchingScreen = true;\n    this.moveEvent(x, y);\n\n    if (!this.getTouchedConnection()) {\n      this.unselectAllConnections();\n    }\n\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n\n    if (this.inCircle.isCloseTo(this.x, this.y)) {\n      port = this.inCircle.mouseEvent(this.x, this.y, this.radianNew[utils.inType]);\n    } else if (this.outCircle.isCloseTo(this.x, this.y)) {\n      port = this.outCircle.mouseEvent(this.x, this.y, this.radianNew[utils.outType]);\n    }\n\n    if (port) {\n      this._touchedPort = port;\n    }\n  }\n\n  moveEvent(x, y) {\n    this.x = x;\n    this.y = y;\n    this.isTouchingScreen = true;\n    this.radianNew[utils.inType] = this.radiansFromCenter(this.x, this.y, this.inCircle);\n    this.radianNew[utils.outType] = this.radiansFromCenter(this.x, this.y, this.outCircle);\n\n    if (this._touchedPort) {\n      this.findHoveredPort();\n    }\n  }\n\n  releaseEvent(x, y) {\n    this.x = x;\n    this.y = y;\n    this.isTouchingScreen = false;\n    const distMoved = utils.getDistance(this.touchX, this.touchY, x, y);\n\n    if (distMoved < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n    } else {\n      if (this._touchedPort && this._hoveredPort) {\n        this.makeConnection(this._hoveredPort, this._touchedPort);\n      }\n\n      this.unselectAllConnections();\n      this.clearCirclesTouchedHovered();\n    }\n  }\n\n  releaseWithoutMoving() {\n    // only de-select all the connections if there was a tap somewhere else\n    const didDeleteAConnection = this.handleDeleteConnection();\n\n    if (!didDeleteAConnection) {\n      this.unselectAllConnections();\n    } // find which Connection is being interacted with\n\n\n    if (this._touchedPort) {\n      // then, find the interactive connection\n      this.unselectAllConnections();\n\n      for (let name in this.connections) {\n        const conn = this.connections[name];\n\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()) {\n          conn.selected = true;\n        }\n      }\n    } else {\n      this.inCircle.tapEvent();\n      this.outCircle.tapEvent();\n    }\n\n    this.clearCirclesTouchedHovered();\n  }\n\n  draw() {\n    if (this.touchedPort) {\n      this.drawTouchLine();\n      this.drawTouchedPort();\n\n      if (this.hoveredPort) {\n        this.drawHoveredPort();\n      }\n    }\n  }\n\n  drawTouchedPort() {\n    this.context.save();\n    utils.drawCircle(this.context, this.touchedPort.x, this.touchedPort.y, this.circleRadius, this.circleThickness, utils.colors.highlight(), undefined);\n    this.context.restore();\n  }\n\n  drawTouchLine() {\n    this.context.save();\n    utils.drawLine(this.context, this.touchedPort.x, this.touchedPort.y, this.x, this.y, fingerDefaults.touchedLineWidth, utils.colors.highlight());\n    this.context.restore(); // then two smaller filled in circles to cover the tips of the line\n\n    this.context.save();\n    utils.drawCircle(this.context, this.touchedPort.x, this.touchedPort.y, fingerDefaults.touchedLineWidth, 0, undefined, utils.colors.highlight());\n    utils.drawCircle(this.context, this.x, this.y, fingerDefaults.touchedLineWidth, 0, undefined, utils.colors.highlight());\n    this.context.restore();\n  }\n\n  drawHoveredPort() {\n    this.context.save();\n    utils.drawCircle(this.context, this.hoveredPort.x, this.hoveredPort.y, this.circleRadius, this.circleThickness, utils.colors.highlight(), undefined);\n    this.context.restore();\n  }\n\n  findHoveredPort() {\n    this._hoveredPort = this.getHoveredPortFromCircle(this.outCircle);\n\n    if (this._hoveredPort) {\n      return;\n    }\n\n    this._hoveredPort = this.getHoveredPortFromCircle(this.inCircle);\n\n    if (this._hoveredPort) {\n      return;\n    }\n  }\n\n  getHoveredPortFromCircle(circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n\n    if (this._touchedPort.type === circle.type) {\n      return;\n    }\n\n    for (let arc of circle.getExpandedArcs()) {\n      for (let port of arc.ports) {\n        if (port.isUserTouching(this.x, this.y)) {\n          return port;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  handleDeleteConnection() {\n    const conn = this.getTouchedConnection();\n\n    if (conn) {\n      this.onDeleteConnection(conn);\n      return true;\n    }\n\n    return false;\n  }\n\n  getTouchedConnection() {\n    for (let i in this.connections) {\n      const conn = this.connections[i];\n\n      if (conn.isUserTouching(this.x, this.y)) {\n        return conn;\n      }\n    }\n\n    return undefined;\n  }\n\n  unselectAllConnections() {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  clearCirclesTouchedHovered() {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n  }\n\n  makeConnection(port1, port2) {\n    if (port1.type === utils.inType) {\n      this.onMakeConnection(port1, port2);\n    } else {\n      this.onMakeConnection(port2, port1);\n    }\n  }\n\n  radiansFromCenter(x, y, circle) {\n    const xDist = Math.abs(circle.x - x);\n    const yDist = Math.abs(circle.y - y);\n\n    if (x > circle.x) {\n      if (y > circle.y) {\n        // bottom right\n        return Math.atan(yDist / xDist);\n      } else if (y < circle.y) {\n        // top right\n        return Math.atan(xDist / yDist) + Math.PI * 1.5;\n      } else {\n        // we're touching the y line\n        return 0;\n      }\n    } else if (x < circle.x) {\n      if (y > circle.y) {\n        // bottom left\n        return Math.atan(xDist / yDist) + Math.PI * 0.5;\n      } else if (y < circle.y) {\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      } else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    } else {\n      //we're touching the x line\n      if (y > circle.y) {\n        return Math.PI * 0.5;\n      } else if (y < circle.y) {\n        return Math.PI * 1.5;\n      } else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n\n}\n\nexport { Finger };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Finger.js"],"names":["utils","fingerDefaults","tapPixelsMovedThresh","touchCircleRadiusScaler","touchCircleThicknessScaler","touchedLineWidth","Finger","constructor","context","inCircle","outCircle","connections","onMakeConnection","onDeleteConnection","_touchedPort","undefined","_hoveredPort","circleRadius","circleThickness","x","y","touchX","touchY","isTouchingScreen","radianNew","inType","outType","radianPrev","Object","assign","touchedPort","hoveredPort","adjustToScreenSize","screenSize","update","touched","radiansMoved","touchEvent","moveEvent","getTouchedConnection","unselectAllConnections","clearTouchedHovered","port","isCloseTo","mouseEvent","radiansFromCenter","findHoveredPort","releaseEvent","distMoved","getDistance","releaseWithoutMoving","makeConnection","clearCirclesTouchedHovered","didDeleteAConnection","handleDeleteConnection","name","conn","inPort","isTouched","outPort","selected","tapEvent","draw","drawTouchLine","drawTouchedPort","drawHoveredPort","save","drawCircle","colors","highlight","restore","drawLine","getHoveredPortFromCircle","circle","arcs","length","type","arc","getExpandedArcs","ports","isUserTouching","i","port1","port2","xDist","Math","abs","yDist","atan","PI"],"mappings":"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","sourcesContent":["import * as utils from './PatchbayUtils'\n\nconst fingerDefaults = {\n  tapPixelsMovedThresh: 3,\n  touchCircleRadiusScaler: 0.1,\n  touchCircleThicknessScaler: 0.01,\n  touchedLineWidth: 3\n};\n\nclass Finger {\n  constructor (context, inCircle, outCircle, connections, onMakeConnection, onDeleteConnection) {\n    this.context = context;\n    this.inCircle = inCircle;\n    this.outCircle = outCircle;\n    this.connections = connections;\n\n    this.onMakeConnection = onMakeConnection;\n    this.onDeleteConnection = onDeleteConnection;\n\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n\n    this.circleRadius = undefined;\n    this.circleThickness = undefined;\n\n    this.x = undefined;\n    this.y = undefined;\n    this.touchX = undefined;\n    this.touchY = undefined;\n\n    this.isTouchingScreen = false;\n\n    this.radianNew = {};\n    this.radianNew[utils.inType] = 0;\n    this.radianNew[utils.outType] = 0;\n    this.radianPrev = Object.assign({}, this.radianNew);\n  }\n\n  get touchedPort () { return this._touchedPort; }\n\n  get hoveredPort () { return this._hoveredPort; }\n\n  adjustToScreenSize (screenSize) {\n    this.circleRadius = screenSize * fingerDefaults.touchCircleRadiusScaler;\n    this.circleThickness = screenSize * fingerDefaults.touchCircleThicknessScaler;\n  }\n\n  update () {\n    if (!this._touchedPort) {\n      if(this.inCircle.touched){\n        this.inCircle.radiansMoved = this.radianNew[utils.inType] - this.radianPrev[utils.inType];\n      }\n      else if(this.outCircle.touched){\n        this.outCircle.radiansMoved = this.radianNew[utils.outType] - this.radianPrev[utils.outType];\n      }\n    }\n    this.radianPrev = Object.assign({}, this.radianNew);\n  }\n\n  touchEvent (x, y) {\n    this.touchX = x;\n    this.touchY = y;\n    this.isTouchingScreen = true;\n    this.moveEvent(x, y);\n    if (!this.getTouchedConnection()) {\n      this.unselectAllConnections();\n    }\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    let port = undefined;\n    if(this.inCircle.isCloseTo(this.x, this.y)){\n      port = this.inCircle.mouseEvent(this.x, this.y, this.radianNew[utils.inType]);\n    }\n    else if(this.outCircle.isCloseTo(this.x, this.y)){\n      port = this.outCircle.mouseEvent(this.x, this.y, this.radianNew[utils.outType]);\n    }\n    if (port) {\n      this._touchedPort = port;\n    }\n  }\n\n  moveEvent (x, y) {\n    this.x = x;\n    this.y = y;\n    this.isTouchingScreen = true;\n    this.radianNew[utils.inType] = this.radiansFromCenter(\n      this.x, this.y, this.inCircle);\n    this.radianNew[utils.outType] = this.radiansFromCenter(\n      this.x, this.y, this.outCircle);\n    if (this._touchedPort) {\n      this.findHoveredPort();\n    }\n  }\n\n  releaseEvent (x, y) {\n    this.x = x;\n    this.y = y;\n    this.isTouchingScreen = false;\n    const distMoved = utils.getDistance(this.touchX, this.touchY, x, y);\n    if (distMoved < fingerDefaults.tapPixelsMovedThresh) {\n      this.releaseWithoutMoving(x, y);\n    }\n    else {\n      if (this._touchedPort && this._hoveredPort){\n        this.makeConnection(this._hoveredPort, this._touchedPort);\n      }\n      this.unselectAllConnections();\n      this.clearCirclesTouchedHovered();\n    }\n  }\n\n  releaseWithoutMoving () {\n    // only de-select all the connections if there was a tap somewhere else\n    const didDeleteAConnection = this.handleDeleteConnection()\n    if (!didDeleteAConnection) {\n      this.unselectAllConnections();\n    }\n    // find which Connection is being interacted with\n    if(this._touchedPort){\n      // then, find the interactive connection\n      this.unselectAllConnections();\n      for (let name in this.connections){\n        const conn = this.connections[name];\n        if (conn.inPort.isTouched() || conn.outPort.isTouched()){\n          conn.selected = true;\n        }\n      }\n    }\n    else {\n      this.inCircle.tapEvent();\n      this.outCircle.tapEvent();\n    }\n    this.clearCirclesTouchedHovered();\n  }\n\n  draw () {\n    if (this.touchedPort) {\n      this.drawTouchLine();\n      this.drawTouchedPort();\n      if (this.hoveredPort) {\n        this.drawHoveredPort();\n      }\n    }\n  }\n\n  drawTouchedPort () {\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      this.circleRadius, this.circleThickness,\n      utils.colors.highlight(), undefined\n    );\n    this.context.restore();\n  }\n\n  drawTouchLine () {\n    this.context.save();\n    utils.drawLine(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      this.x, this.y,\n      fingerDefaults.touchedLineWidth, utils.colors.highlight()\n    );\n    this.context.restore();\n    // then two smaller filled in circles to cover the tips of the line\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.touchedPort.x, this.touchedPort.y,\n      fingerDefaults.touchedLineWidth, 0,\n      undefined, utils.colors.highlight()\n    );\n    utils.drawCircle(\n      this.context,\n      this.x, this.y,\n      fingerDefaults.touchedLineWidth, 0,\n      undefined, utils.colors.highlight()\n    );\n    this.context.restore();\n  }\n\n  drawHoveredPort () {\n    this.context.save();\n    utils.drawCircle(\n      this.context,\n      this.hoveredPort.x, this.hoveredPort.y,\n      this.circleRadius, this.circleThickness,\n      utils.colors.highlight(), undefined\n    );\n    this.context.restore();\n  }\n\n  findHoveredPort () {\n    this._hoveredPort = this.getHoveredPortFromCircle(this.outCircle);\n    if (this._hoveredPort) {\n      return;\n    }\n    this._hoveredPort = this.getHoveredPortFromCircle(this.inCircle);\n    if (this._hoveredPort) {\n      return;\n    }\n  }\n\n  getHoveredPortFromCircle (circle) {\n    if (circle.arcs.length === 0) {\n      return;\n    }\n    if (this._touchedPort.type === circle.type) {\n      return;\n    }\n    for (let arc of circle.getExpandedArcs()) {\n      for (let port of arc.ports) {\n        if (port.isUserTouching(this.x, this.y)) {\n          return port;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  handleDeleteConnection () {\n    const conn = this.getTouchedConnection();\n    if (conn) {\n      this.onDeleteConnection(conn);\n      return true;\n    }\n    return false;\n  }\n\n  getTouchedConnection () {\n    for(let i in this.connections){\n      const conn = this.connections[i];\n      if (conn.isUserTouching(this.x, this.y)) {\n        return conn;\n      }\n    }\n    return undefined;\n  }\n\n  unselectAllConnections () {\n    for (let name in this.connections) {\n      this.connections[name].selected = false;\n    }\n  }\n\n  clearCirclesTouchedHovered () {\n    this.inCircle.clearTouchedHovered();\n    this.outCircle.clearTouchedHovered();\n    this._touchedPort = undefined;\n    this._hoveredPort = undefined;\n  }\n\n  makeConnection (port1, port2) {\n    if (port1.type === utils.inType){\n      this.onMakeConnection(port1, port2);\n    }\n    else{\n      this.onMakeConnection(port2, port1);\n    }\n  }\n\n  radiansFromCenter (x, y, circle) {\n    const xDist = Math.abs(circle.x - x);\n    const yDist = Math.abs(circle.y - y);\n    if (x > circle.x){\n      if (y > circle.y){\n        // bottom right\n        return Math.atan(yDist / xDist);\n      }\n      else if (y < circle.y){\n        // top right\n        return Math.atan(xDist / yDist) + (Math.PI * 1.5);\n      }\n      else {\n        // we're touching the y line\n        return 0;\n      }\n    }\n    else if (x < circle.x){\n      if (y > circle.y){\n        // bottom left\n        return Math.atan(xDist / yDist) + (Math.PI * 0.5);\n      }\n      else if (y < circle.y){\n        // top left\n        return Math.atan(yDist / xDist) + Math.PI;\n      }\n      else {\n        // we're touching the y line\n        return Math.PI;\n      }\n    }\n    else {\n      //we're touching the x line\n      if (y > circle.y){\n        return Math.PI * 0.5;\n      }\n      else if (y < circle.y){\n        return Math.PI * 1.5;\n      }\n      else {\n        // we're touching the middle\n        return 0;\n      }\n    }\n  }\n}\n\nexport { Finger }\n"]},"metadata":{},"sourceType":"module"}