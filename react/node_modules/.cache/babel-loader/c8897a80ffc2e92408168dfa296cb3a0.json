{"ast":null,"code":"import _slicedToArray from \"/Users/andy/Documents/patchbay-react/patchbay-react/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as utils from './PatchbayUtils';\nimport { Arc } from './Arc';\nconst circleDefaults = {\n  autoStepSize: 0.1,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 200,\n  textXOffsetScaler: 0.075,\n  arcTextScaler: 0.04,\n  typeFontSizeScaler: 0.025,\n  labelOffsetYScaler: 2\n};\n\nclass Circle {\n  constructor(context, type, radiusPercentage, thicknessPercentage, getGlobalTouchedPort, getGlobalHoveredPort) {\n    this.context = context;\n    this._type = type;\n    this.getGlobalTouchedPort = getGlobalTouchedPort;\n    this.getGlobalHoveredPort = getGlobalHoveredPort;\n    this.radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thicknessPercentage;\n    this.lineWidth = undefined;\n    this.radius = undefined;\n    this.typeFontSize = undefined;\n    this.arcTextScaler = undefined;\n    this._x = 0;\n    this._y = 0;\n    this._touched = false;\n    this._arcs = [];\n    this.arcStartEndPoints = [];\n    this.expandedOffset = 0;\n    this.rotatePercent = 0;\n    this._radiansMoved = 0;\n    this.isAutoMoving = false;\n    this.autoTargetOffset = 0;\n    this.autoStepTotal = 0;\n    this.autoStepCount = 0;\n  } // GETTERS\n\n\n  get type() {\n    return this._type;\n  }\n\n  get touched() {\n    return this._touched;\n  }\n\n  get arcs() {\n    return this._arcs;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  } // SETTERS\n\n\n  set radiansMoved(newVal) {\n    this._radiansMoved = newVal;\n  }\n\n  set x(newVal) {\n    this._x = newVal;\n  }\n\n  set y(newVal) {\n    this._y = newVal;\n  }\n\n  createArc(name, color, id) {\n    const arc = new Arc(this.context, this, this._type, name, id, color, this.getGlobalTouchedPort, this.getGlobalHoveredPort);\n    arc.adjustToScreenSize(this.radius, this.lineWidth, this.x, this.y);\n    return arc;\n  }\n\n  addArc(arc) {\n    this._arcs.push(arc);\n\n    this.updateDimensionStuff();\n  }\n\n  deleteArc(arc) {\n    for (let _ref of this._arcs.entries()) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      let i = _ref2[0];\n      let a = _ref2[1];\n\n      if (arc === a) {\n        this._arcs.splice(i, 1);\n\n        if (this.expandedOffset >= this._arcs.length) {\n          this.expandedOffset = this._arcs.length - 1;\n        }\n\n        this.updateDimensionStuff();\n        return;\n      }\n    }\n  }\n\n  deleteArcFromId(id) {\n    const arc = this.getArcFromId(id);\n\n    if (arc) {\n      this.deleteArc(arc);\n    }\n  }\n\n  getArcFromId(id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n\n    return undefined;\n  }\n\n  holdsTouchedPort() {\n    const port = this.getGlobalTouchedPort();\n    return Boolean(port && port.type === this.type);\n  }\n\n  getExpandedArcs() {\n    const arcs = [this._arcs[this.expandedOffset]];\n\n    if (this.rotatePercent > 0 && this.rotatePercent < 1) {\n      arcs.push(this._arcs[(this.expandedOffset + 1) % this._arcs.length]);\n    }\n\n    return arcs;\n  }\n\n  incrementArcOffset() {\n    this.expandedOffset = (this.expandedOffset + 1) % this._arcs.length;\n  }\n\n  decrementArcOffset() {\n    this.expandedOffset -= this.expandedOffset === 0 ? -this._arcs.length + 1 : 1;\n  }\n\n  adjustToScreenSize(screenSize) {\n    this.lineWidth = this.relativeLineWidth * screenSize;\n    this.radius = this.radiusPercentage * screenSize;\n    this.typeFontSize = circleDefaults.typeFontSizeScaler * screenSize;\n    this.arcTextScaler = circleDefaults.arcTextScaler * screenSize;\n\n    for (let arc of this._arcs) {\n      arc.adjustToScreenSize(this.radius, this.lineWidth, this.x, this.y);\n    }\n  }\n\n  update() {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    } else {\n      this.updateRotateDrag();\n    }\n\n    for (let i = 0; i < this._arcs.length; i++) {\n      const _this$transpose = this.transpose(i),\n            _this$transpose2 = _slicedToArray(_this$transpose, 2),\n            start = _this$transpose2[0],\n            end = _this$transpose2[1];\n\n      const isExpanded = Boolean(i < 2);\n      const arcIndex = (i + this.expandedOffset) % this._arcs.length;\n      const sizeScaler = this.expandedOffset === arcIndex ? 1 - this.rotatePercent : this.rotatePercent;\n\n      this._arcs[arcIndex].update(start, end, isExpanded, sizeScaler);\n    }\n  }\n\n  updateRotateDrag() {\n    if (this._radiansMoved === 0) {\n      return;\n    }\n\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = utils.PI - this._radiansMoved % utils.PI;\n      this._radiansMoved *= -1;\n    }\n\n    if (!this.touched) {\n      this._radiansMoved *= circleDefaults.rotateFeedback;\n\n      if (this._radiansMoved < 0.0001) {\n        this._radiansMoved = 0;\n      }\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - relativeMovement % 1;\n    } else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + relativeMovement % 1;\n    }\n\n    if (relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      } else {\n        this.direction = 1;\n      }\n\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.rotatePercent -= animStep;\n\n      if (this.rotatePercent >= 1) {\n        this.incrementArcOffset();\n        this.rotatePercent -= 1;\n      } else if (this.rotatePercent < 0) {\n        this.decrementArcOffset();\n        this.rotatePercent += 1;\n      }\n    }\n  }\n\n  updateDimensionStuff() {\n    this.arcStartEndPoints = [];\n\n    if (this._arcs.length === 1) {\n      this.arcStartEndPoints = [{\n        'start': utils.PI / 2,\n        'end': utils.PI / 2\n      }];\n    } else if (this._arcs.length === 2) {\n      this.arcStartEndPoints = [{\n        'start': utils.PI,\n        'end': utils.PI2\n      }, {\n        'start': 0,\n        'end': utils.PI\n      }];\n    } else {\n      this.arcStartEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n\n      for (let i = 1; i < this._arcs.length; i++) {\n        this.arcStartEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  transpose(i) {\n    // `target` is the index of the neighboring arc\n    // in the direction that we are rotating\n    let target = i - 1;\n\n    if (target < 0) {\n      target = this._arcs.length + target;\n    } else if (target >= this._arcs.length) {\n      target = target % this._arcs.length;\n    } // the start/end radians are pre-calculated when arcs are added/deleted\n    //\n\n\n    const realStart = this.arcStartEndPoints[i].start;\n    let startDiff = this.arcStartEndPoints[target].start - realStart;\n    const realEnd = this.arcStartEndPoints[i].end;\n    let endDiff = this.arcStartEndPoints[target].end - realEnd;\n\n    if (i === 1) {\n      startDiff = startDiff * -1;\n      endDiff = -utils.PI2 + endDiff;\n    }\n\n    let currentStart = startDiff * this.rotatePercent + realStart;\n    let currentEnd = endDiff * this.rotatePercent + realEnd;\n\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    } else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    } else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n\n    return [currentStart + circleDefaults.padding, currentEnd - circleDefaults.padding];\n  }\n\n  updateAutoMoving() {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.rotatePercent += this.autoStepSize;\n      this.autoStepCount++;\n\n      if (this.rotatePercent >= 1) {\n        this.incrementArcOffset();\n        this.rotatePercent = 0;\n      } else if (this.rotatePercent < 0) {\n        this.decrementArcOffset();\n        this.rotatePercent = 1 + this.rotatePercent;\n      }\n    } else {\n      this.isAutoMoving = false;\n      this.expandedOffset = this.autoTargetOffset;\n      this.rotatePercent = 0;\n    }\n  }\n\n  drawArcs() {\n    if (this._arcs.length > 0) {\n      this.context.save();\n      this.context.translate(this._x, this._y);\n      this.context.textAlign = 'center'; // draw the TYPE text in the center of the Circle\n\n      let labelOffsetYScaler = circleDefaults.labelOffsetYScaler;\n      labelOffsetYScaler *= this._type === utils.inType ? -1 : 1;\n      const typeYOffset = this.typeFontSize * labelOffsetYScaler;\n      this.context.font = utils.font(this.typeFontSize);\n      this.context.fillStyle = utils.colors.black();\n      this.context.fillText(this._type.toUpperCase(), 0, typeYOffset); // then draw the currently displayed arc's name\n\n      const arc0 = this._arcs[this.expandedOffset];\n      const arc0FontSize = this.arcTextScaler * arc0.sizeScaler;\n      let xOffset0 = this.lineWidth * this.arcTextScaler * this.rotatePercent;\n\n      if (arc0.type === utils.outType) {\n        xOffset0 *= -1;\n      }\n\n      xOffset0 *= circleDefaults.textXOffsetScaler;\n      this.context.font = utils.font(arc0FontSize);\n      this.context.fillStyle = arc0.color(Math.min(arc0.sizeScaler, 1));\n      this.context.fillText(arc0.name, xOffset0, 0); // draw the next-in-line Arc's label (fading in/out)\n\n      const arc1 = this._arcs[(this.expandedOffset + 1) % this._arcs.length];\n      const arc1FontSize = this.arcTextScaler * arc1.sizeScaler;\n      let xOffset1 = this.lineWidth * this.arcTextScaler * (1 - this.rotatePercent);\n\n      if (arc1.type === utils.outType) {\n        xOffset1 *= -1;\n      }\n\n      xOffset1 *= circleDefaults.textXOffsetScaler;\n      xOffset1 *= -1;\n      this.context.font = utils.font(arc1FontSize);\n      this.context.fillStyle = arc1.color(Math.min(arc1.sizeScaler, 1));\n      this.context.fillText(arc1.name, xOffset1, 0); // now draw the actual child Arcs\n\n      for (let i = 0; i < this._arcs.length; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.context.restore();\n    }\n  }\n\n  drawNames() {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n\n    if (!this.holdsTouchedPort()) {\n      for (let arc of this._arcs) {\n        if (arc.isSelected) {\n          arc.drawAllPortNames();\n        }\n      }\n    } else {\n      // the touched port is in this circle, so only draw it's name\n      const port = this.getGlobalTouchedPort();\n      const parentArc = port.parent;\n      parentArc.drawPortName(port);\n    }\n\n    this.context.restore();\n  }\n\n  drawPorts() {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n\n    for (let arc of this._arcs) {\n      if (arc.isSelected) {\n        arc.drawPorts();\n      }\n    }\n\n    this.context.restore();\n  }\n\n  mouseEvent(fingerX, fingerY, compRadian) {\n    for (let arc of this.getExpandedArcs()) {\n      const port = arc.getPortNear(fingerX, fingerY);\n\n      if (port) {\n        this._touched = false;\n        return port;\n      }\n    }\n\n    this._touched = true; // see which arc was touched\n\n    for (let arc of this._arcs) {\n      if (compRadian > arc.start && compRadian < arc.end) {\n        arc.touched = true;\n        break;\n      }\n    }\n\n    return undefined;\n  }\n\n  startAutoMove(newOffset) {\n    this.autoTargetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this.expandedOffset + this._arcs.length);\n    const moveDown = newOffset - this.expandedOffset;\n    let arcsToMove = moveUp - this.rotatePercent;\n\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        arcsToMove = moveDown + this._arcs.length + this.rotatePercent;\n      } else if (moveDown === 0) {\n        arcsToMove = (moveDown - this.rotatePercent) % this._arcs.length;\n      } else {\n        arcsToMove = (moveDown + this.rotatePercent) % this._arcs.length;\n      }\n    }\n\n    this.autoStepSize = circleDefaults.autoStepSize;\n    this.autoStepTotal = arcsToMove / this.autoStepSize;\n\n    if (this.autoStepTotal < 0) {\n      this.autoStepTotal *= -1;\n      this.autoStepSize *= -1;\n    }\n\n    this.autoStepCount = 0;\n  }\n\n  isCloseTo(x, y) {\n    const distFromCenter = utils.getDistance(this._x, this._y, x, y);\n    const halfWidth = this.lineWidth / 2;\n    const outerRad = this.radius + halfWidth;\n    const innerRad = this.radius - halfWidth;\n\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n\n    return false;\n  }\n\n  tapEvent() {\n    if (this._touched) {\n      for (let i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered() {\n    this._touched = false;\n\n    for (let i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n    }\n  }\n\n}\n\nexport { Circle };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Circle.js"],"names":["utils","Arc","circleDefaults","autoStepSize","rotateFeedback","padding","PI","textXOffsetScaler","arcTextScaler","typeFontSizeScaler","labelOffsetYScaler","Circle","constructor","context","type","radiusPercentage","thicknessPercentage","getGlobalTouchedPort","getGlobalHoveredPort","_type","relativeLineWidth","lineWidth","undefined","radius","typeFontSize","_x","_y","_touched","_arcs","arcStartEndPoints","expandedOffset","rotatePercent","_radiansMoved","isAutoMoving","autoTargetOffset","autoStepTotal","autoStepCount","touched","arcs","x","y","radiansMoved","newVal","createArc","name","color","id","arc","adjustToScreenSize","addArc","push","updateDimensionStuff","deleteArc","entries","i","a","splice","length","deleteArcFromId","getArcFromId","holdsTouchedPort","port","Boolean","getExpandedArcs","incrementArcOffset","decrementArcOffset","screenSize","update","updateAutoMoving","updateRotateDrag","transpose","start","end","isExpanded","arcIndex","sizeScaler","relativeMovement","PI2","Math","abs","direction","animStep","smallerWidth","target","realStart","startDiff","realEnd","endDiff","currentStart","currentEnd","drawArcs","save","translate","textAlign","inType","typeYOffset","font","fillStyle","colors","black","fillText","toUpperCase","arc0","arc0FontSize","xOffset0","outType","min","arc1","arc1FontSize","xOffset1","drawArc","restore","drawNames","isSelected","drawAllPortNames","parentArc","parent","drawPortName","drawPorts","mouseEvent","fingerX","fingerY","compRadian","getPortNear","startAutoMove","newOffset","moveUp","moveDown","arcsToMove","isCloseTo","distFromCenter","getDistance","halfWidth","outerRad","innerRad","tapEvent","clearTouchedHovered"],"mappings":"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","sourcesContent":["import * as utils from './PatchbayUtils'\nimport { Arc } from './Arc'\n\nconst circleDefaults = {\n  autoStepSize: 0.1,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 200,\n  textXOffsetScaler: 0.075,\n  arcTextScaler: 0.04,\n  typeFontSizeScaler: 0.025,\n  labelOffsetYScaler: 2\n};\n\nclass Circle {\n  constructor (context, type, radiusPercentage, thicknessPercentage, getGlobalTouchedPort, getGlobalHoveredPort) {\n    this.context = context;\n\n    this._type = type;\n\n    this.getGlobalTouchedPort = getGlobalTouchedPort;\n    this.getGlobalHoveredPort = getGlobalHoveredPort;\n\n    this.radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thicknessPercentage;\n    this.lineWidth = undefined;\n    this.radius = undefined;\n    this.typeFontSize = undefined;\n    this.arcTextScaler = undefined;\n\n    this._x = 0;\n    this._y = 0;\n\n    this._touched = false;\n\n    this._arcs = [];\n\n    this.arcStartEndPoints = [];\n    this.expandedOffset = 0;\n    this.rotatePercent = 0;\n    this._radiansMoved = 0;\n\n    this.isAutoMoving = false;\n    this.autoTargetOffset = 0;\n    this.autoStepTotal = 0;\n    this.autoStepCount = 0;\n  }\n\n  // GETTERS\n\n  get type () { return this._type; }\n\n  get touched () { return this._touched; }\n\n  get arcs () { return this._arcs; }\n\n  get x () { return this._x; }\n\n  get y () { return this._y; }\n\n  // SETTERS\n\n  set radiansMoved (newVal) { this._radiansMoved = newVal; }\n\n  set x (newVal) { this._x = newVal; }\n\n  set y (newVal) { this._y = newVal; }\n\n  createArc (name, color, id) {\n    const arc = new Arc(\n      this.context,\n      this,\n      this._type,\n      name,\n      id,\n      color,\n      this.getGlobalTouchedPort,\n      this.getGlobalHoveredPort\n    );\n    arc.adjustToScreenSize(this.radius, this.lineWidth, this.x, this.y);\n    return arc;\n  }\n\n  addArc (arc) {\n    this._arcs.push(arc);\n    this.updateDimensionStuff();\n  }\n\n  deleteArc (arc) {\n    for (let [i, a] of this._arcs.entries()) {\n      if (arc === a) {\n        this._arcs.splice(i, 1);\n        if (this.expandedOffset >= this._arcs.length) {\n          this.expandedOffset = this._arcs.length - 1;\n        }\n        this.updateDimensionStuff();\n        return;\n      }\n    }\n  }\n\n  deleteArcFromId (id) {\n    const arc = this.getArcFromId(id);\n    if (arc) {\n      this.deleteArc(arc);\n    }\n  }\n\n  getArcFromId (id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n    return undefined;\n  }\n\n  holdsTouchedPort () {\n    const port = this.getGlobalTouchedPort();\n    return Boolean(port && port.type === this.type);\n  }\n\n  getExpandedArcs () {\n    const arcs = [this._arcs[this.expandedOffset]];\n    if (this.rotatePercent > 0 && this.rotatePercent < 1) {\n      arcs.push(this._arcs[(this.expandedOffset + 1) % this._arcs.length]);\n    }\n    return arcs;\n  }\n\n  incrementArcOffset () {\n    this.expandedOffset = (this.expandedOffset + 1) % this._arcs.length;\n  }\n\n  decrementArcOffset () {\n    this.expandedOffset -= this.expandedOffset === 0 ? -this._arcs.length + 1 : 1;\n  }\n\n  adjustToScreenSize (screenSize) {\n    this.lineWidth = this.relativeLineWidth * screenSize;\n    this.radius = this.radiusPercentage * screenSize;\n    this.typeFontSize = circleDefaults.typeFontSizeScaler * screenSize;\n    this.arcTextScaler = circleDefaults.arcTextScaler * screenSize;\n    for (let arc of this._arcs) {\n      arc.adjustToScreenSize(this.radius, this.lineWidth, this.x, this.y);\n    }\n  }\n\n  update () {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    }\n    else {\n      this.updateRotateDrag();\n    }\n    for (let i = 0; i < this._arcs.length; i++) {\n      const [start, end] = this.transpose(i);\n      const isExpanded = Boolean(i < 2);\n      const arcIndex = (i + this.expandedOffset) % this._arcs.length;\n      const sizeScaler = (this.expandedOffset === arcIndex) ? 1 - this.rotatePercent : this.rotatePercent;\n      this._arcs[arcIndex].update(start, end, isExpanded, sizeScaler);\n    }\n  }\n\n  updateRotateDrag () {\n    if (this._radiansMoved === 0) {\n      return\n    }\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = utils.PI - (this._radiansMoved % utils.PI);\n      this._radiansMoved *= -1;\n    }\n    if (!this.touched) {\n      this._radiansMoved *= circleDefaults.rotateFeedback;\n      if (this._radiansMoved < 0.0001) {\n        this._radiansMoved = 0;\n      }\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - (relativeMovement % 1);\n    }\n    else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + (relativeMovement % 1);\n    }\n    if (relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      }\n      else {\n        this.direction = 1;\n      }\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.rotatePercent -= animStep;\n\n      if (this.rotatePercent >= 1) {\n        this.incrementArcOffset()\n        this.rotatePercent -= 1;\n      }\n      else if (this.rotatePercent < 0) {\n        this.decrementArcOffset();\n        this.rotatePercent += 1;\n      }\n    }\n  }\n\n  updateDimensionStuff () {\n    this.arcStartEndPoints = [];\n    if (this._arcs.length === 1) {\n      this.arcStartEndPoints = [\n        {\n          'start': utils.PI / 2,\n          'end': utils.PI / 2\n        }\n      ];\n    }\n    else if (this._arcs.length === 2) {\n      this.arcStartEndPoints = [\n        {\n          'start': utils.PI,\n          'end': utils.PI2\n        },\n        {\n          'start': 0,\n          'end': utils.PI\n        },\n      ];\n    }\n    else{\n      this.arcStartEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n      for (let i = 1; i < this._arcs.length; i++) {\n        this.arcStartEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  transpose (i) {\n    // `target` is the index of the neighboring arc\n    // in the direction that we are rotating\n    let target = i - 1;\n    if (target < 0) {\n      target = this._arcs.length + target;\n    }\n    else if (target >= this._arcs.length) {\n      target = target % this._arcs.length;\n    }\n    // the start/end radians are pre-calculated when arcs are added/deleted\n    //\n    const realStart = this.arcStartEndPoints[i].start;\n    let startDiff = this.arcStartEndPoints[target].start - realStart;\n    const realEnd = this.arcStartEndPoints[i].end;\n    let endDiff = this.arcStartEndPoints[target].end - realEnd;\n    if (i === 1) {\n      startDiff = startDiff * -1;\n      endDiff = -utils.PI2 + endDiff;\n    }\n\n    let currentStart = (startDiff * this.rotatePercent) + realStart;\n    let currentEnd = (endDiff * this.rotatePercent) + realEnd;\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    }\n    else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    }\n    else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n    return [\n      currentStart + circleDefaults.padding,\n      currentEnd - circleDefaults.padding\n    ];\n  }\n\n  updateAutoMoving () {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.rotatePercent += this.autoStepSize;\n      this.autoStepCount++;\n      if (this.rotatePercent >= 1) {\n        this.incrementArcOffset();\n        this.rotatePercent = 0;\n      }\n      else if (this.rotatePercent < 0) {\n        this.decrementArcOffset();\n        this.rotatePercent = 1 + this.rotatePercent;\n      }\n    }\n    else {\n      this.isAutoMoving = false;\n      this.expandedOffset = this.autoTargetOffset;\n      this.rotatePercent = 0;\n    }\n  }\n\n  drawArcs () {\n    if (this._arcs.length > 0) {\n      this.context.save();\n      this.context.translate(this._x, this._y);\n      this.context.textAlign = 'center';\n\n      // draw the TYPE text in the center of the Circle\n      let labelOffsetYScaler = circleDefaults.labelOffsetYScaler;\n      labelOffsetYScaler *= (this._type === utils.inType) ? -1 : 1;\n      const typeYOffset = this.typeFontSize * labelOffsetYScaler;\n      this.context.font = utils.font(this.typeFontSize);\n      this.context.fillStyle = utils.colors.black();\n      this.context.fillText(this._type.toUpperCase(), 0, typeYOffset);\n\n      // then draw the currently displayed arc's name\n      const arc0 = this._arcs[this.expandedOffset];\n      const arc0FontSize = this.arcTextScaler * arc0.sizeScaler;\n      let xOffset0 = this.lineWidth * this.arcTextScaler * this.rotatePercent;\n      if (arc0.type === utils.outType) {\n        xOffset0 *= -1;\n      }\n      xOffset0 *= circleDefaults.textXOffsetScaler;\n      this.context.font = utils.font(arc0FontSize);\n      this.context.fillStyle = arc0.color(Math.min(arc0.sizeScaler, 1));\n      this.context.fillText(arc0.name, xOffset0, 0);\n\n      // draw the next-in-line Arc's label (fading in/out)\n      const arc1 = this._arcs[(this.expandedOffset + 1) % this._arcs.length];\n      const arc1FontSize = this.arcTextScaler * arc1.sizeScaler;\n      let xOffset1 = this.lineWidth * this.arcTextScaler * (1 - this.rotatePercent);\n      if (arc1.type === utils.outType) {\n        xOffset1 *= -1;\n      }\n      xOffset1 *= circleDefaults.textXOffsetScaler;\n      xOffset1 *= -1;\n      this.context.font = utils.font(arc1FontSize);\n      this.context.fillStyle = arc1.color(Math.min(arc1.sizeScaler, 1));\n      this.context.fillText(arc1.name, xOffset1, 0);\n\n      // now draw the actual child Arcs\n      for (let i = 0; i < this._arcs.length; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.context.restore();\n    }\n  }\n\n  drawNames () {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n    if (!this.holdsTouchedPort()) {\n      for (let arc of this._arcs) {\n        if (arc.isSelected) {\n          arc.drawAllPortNames();\n        }\n      }\n    }\n    else {\n      // the touched port is in this circle, so only draw it's name\n      const port = this.getGlobalTouchedPort();\n      const parentArc = port.parent;\n      parentArc.drawPortName(port);\n    }\n    this.context.restore();\n  }\n\n  drawPorts () {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n    for (let arc of this._arcs) {\n      if (arc.isSelected) {\n        arc.drawPorts();\n      }\n    }\n    this.context.restore();\n  }\n\n  mouseEvent (fingerX, fingerY, compRadian) {\n    for (let arc of this.getExpandedArcs()) {\n      const port = arc.getPortNear(fingerX, fingerY);\n      if (port) {\n        this._touched = false;\n        return port;\n      }\n    }\n    this._touched = true;\n    // see which arc was touched\n    for (let arc of this._arcs) {\n      if (compRadian > arc.start && compRadian < arc.end) {\n        arc.touched = true;\n        break;\n      }\n    }\n    return undefined;\n  }\n\n  startAutoMove (newOffset) {\n    this.autoTargetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this.expandedOffset + this._arcs.length);\n    const moveDown = newOffset - this.expandedOffset;\n    let arcsToMove = moveUp - this.rotatePercent;\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        arcsToMove = moveDown + this._arcs.length + this.rotatePercent;\n      }\n      else if (moveDown === 0) {\n        arcsToMove = (moveDown - this.rotatePercent) % this._arcs.length;\n      }\n      else {\n        arcsToMove = (moveDown + this.rotatePercent) % this._arcs.length;\n      }\n    }\n    this.autoStepSize = circleDefaults.autoStepSize;\n    this.autoStepTotal = arcsToMove / this.autoStepSize;\n    if (this.autoStepTotal < 0) {\n      this.autoStepTotal *= -1;\n      this.autoStepSize *= -1;\n    }\n    this.autoStepCount = 0;\n  }\n\n  isCloseTo (x, y) {\n    const distFromCenter = utils.getDistance(this._x, this._y, x, y);\n    const halfWidth = this.lineWidth / 2;\n    const outerRad = this.radius + halfWidth;\n    const innerRad = this.radius - halfWidth;\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n    return false;\n  }\n\n  tapEvent () {\n    if (this._touched) {\n      for (let i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered () {\n    this._touched = false;\n    for (let i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n    }\n  }\n}\n\nexport { Circle }\n"]},"metadata":{},"sourceType":"module"}