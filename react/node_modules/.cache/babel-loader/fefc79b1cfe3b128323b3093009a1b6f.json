{"ast":null,"code":"import _slicedToArray from \"/Users/andy/Documents/patchbay-react/patchbay-react/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as utils from './DrawUtils';\nimport { Arc } from './Arc';\nconst circleDefaults = {\n  autoStepSize: 0.1,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 200,\n  textXOffsetScaler: 0.075,\n  arcTextScaler: 0.04,\n  typeFontSizeScaler: 0.025,\n  labelOffsetYScaler: 2\n};\n\nclass Circle {\n  constructor(params, type, radiusPercentage, thicknessPercentage) {\n    this.params = params;\n    this.context = params.context;\n    this._type = type;\n    this._radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thicknessPercentage;\n    this._lineWidth = undefined;\n    this._x = 0;\n    this._y = 0;\n    this._touched = false;\n    this._arcs = [];\n    this.arcStartEndPoints = [];\n    this._arcOffset = 0;\n    this.rotatePercent = 0;\n    this._radiansMoved = 0;\n    this.isAutoMoving = false;\n    this.autoTargetOffset = 0;\n    this.autoStepTotal = 0;\n    this.autoStepCount = 0;\n  } // GETTERS\n\n\n  get type() {\n    return this._type;\n  }\n\n  get touched() {\n    return this._touched;\n  }\n\n  get arcs() {\n    return this._arcs;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  } // SETTERS\n\n\n  set radiansMoved(newVal) {\n    this._radiansMoved = newVal;\n  }\n\n  set x(newVal) {\n    this._x = newVal;\n  }\n\n  set y(newVal) {\n    this._y = newVal;\n  }\n\n  holdsTouchedPort() {\n    const port = this.params.touchedPort;\n    return Boolean(port && port.type === this.type);\n  }\n\n  holdsHoveredPort() {\n    const port = this.params.hoveredPort;\n    return Boolean(port && port.type === this.type);\n  }\n\n  getExpandedArcs() {\n    const arcs = [this._arcs[this._arcOffset]];\n\n    if (this.rotatePercent > 0 && this.rotatePercent < 1) {\n      arcs.push(this._arcs[(this._arcOffset + 1) % this._arcs.length]);\n    }\n\n    return arcs;\n  }\n\n  update() {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    } else {\n      this.rotateDrag();\n    }\n\n    const totalArcs = this._arcs.length;\n\n    if (this._arcOffset < totalArcs) {\n      this._lineWidth = Math.floor(this.relativeLineWidth * this.params.screenSize);\n\n      for (let i = 0; i < totalArcs; i++) {\n        const nonHighlightedIndex = (i + this._arcOffset) % totalArcs;\n        const arcIndex = i === 0 ? this._arcOffset : nonHighlightedIndex;\n        const points = this.transpose(i);\n        const sizeScaler = this._arcOffset === arcIndex ? 1 - this.rotatePercent : this.rotatePercent;\n\n        this._arcs[arcIndex].onScreenUpdate(this._radiusPercentage * this.params.screenSize, this._lineWidth, this.x, this.y);\n\n        this._arcs[arcIndex].update(points[0] + circleDefaults.padding, points[1] - circleDefaults.padding, Boolean(i < 2), sizeScaler);\n      }\n    }\n  }\n\n  drawArcs() {\n    if (this._arcs.length > 0) {\n      this.context.save();\n      this.context.translate(this._x, this._y);\n      this.context.textAlign = 'center'; // draw the TYPE text in the center of the Circle\n\n      const typeFontSize = Math.floor(this.params.screenSize * circleDefaults.typeFontSizeScaler);\n      let labelOffsetYScaler = circleDefaults.labelOffsetYScaler;\n      labelOffsetYScaler *= this._type === this.params.inType ? -1 : 1;\n      const typeYOffset = typeFontSize * labelOffsetYScaler;\n      this.context.font = utils.font(typeFontSize);\n      this.context.fillStyle = utils.colors.black();\n      this.context.fillText(this._type.toUpperCase(), 0, typeYOffset);\n      const arcTextScaler = Math.floor(this.params.screenSize * circleDefaults.arcTextScaler); // then draw the currently displayed arc's name\n\n      const arc0 = this._arcs[this._arcOffset];\n      const arc0FontSize = arcTextScaler * arc0.sizeScaler;\n      let xOffset0 = this._lineWidth * arcTextScaler * this.rotatePercent;\n\n      if (arc0.type === this.params.outType) {\n        xOffset0 *= -1;\n      }\n\n      xOffset0 *= circleDefaults.textXOffsetScaler;\n      this.context.font = utils.font(arc0FontSize);\n      this.context.fillStyle = arc0.color(Math.min(arc0.sizeScaler, 1));\n      this.context.fillText(arc0.name, xOffset0, 0); // draw the next-in-line Arc's label (fading in/out)\n\n      const arc1 = this._arcs[(this._arcOffset + 1) % this._arcs.length];\n      const arc1FontSize = arcTextScaler * arc1.sizeScaler;\n      let xOffset1 = this._lineWidth * arcTextScaler * (1 - this.rotatePercent);\n\n      if (arc1.type === this.params.outType) {\n        xOffset1 *= -1;\n      }\n\n      xOffset1 *= circleDefaults.textXOffsetScaler;\n      xOffset1 *= -1;\n      this.context.font = utils.font(arc1FontSize);\n      this.context.fillStyle = arc1.color(Math.min(arc1.sizeScaler, 1));\n      this.context.fillText(arc1.name, xOffset1, 0); // now draw the actual child Arcs\n\n      for (let i = 0; i < this._arcs.length; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.context.restore();\n    }\n  }\n\n  drawNames() {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n\n    if (!this.holdsTouchedPort()) {\n      for (let arc of this._arcs) {\n        if (arc.isSelected) {\n          arc.drawAllPortNames();\n        }\n      }\n    } else {\n      // the touched port is in this circle, so only draw it's name\n      const parentArc = this.params.touchedPort.parent;\n      parentArc.drawPortName(this.params.touchedPort);\n    }\n\n    this.context.restore();\n  }\n\n  drawPorts() {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n\n    for (let arc of this._arcs) {\n      if (arc.isSelected) {\n        arc.drawPorts();\n      }\n    }\n\n    this.context.restore();\n  }\n\n  startAutoMove(newOffset) {\n    this.autoTargetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this._arcOffset + this._arcs.length);\n    const moveDown = newOffset - this._arcOffset;\n    let arcsToMove = moveUp - this.rotatePercent;\n\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        arcsToMove = moveDown + this._arcs.length + this.rotatePercent;\n      } else if (moveDown === 0) {\n        arcsToMove = (moveDown - this.rotatePercent) % this._arcs.length;\n      } else {\n        arcsToMove = (moveDown + this.rotatePercent) % this._arcs.length;\n      }\n    }\n\n    this.autoStepSize = circleDefaults.autoStepSize;\n    this.autoStepTotal = arcsToMove / this.autoStepSize;\n\n    if (this.autoStepTotal < 0) {\n      this.autoStepTotal *= -1;\n      this.autoStepSize *= -1;\n    }\n\n    this.autoStepCount = 0;\n  }\n\n  updateAutoMoving() {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.rotatePercent += this.autoStepSize;\n      this.autoStepCount++;\n\n      if (this.rotatePercent >= 1) {\n        this._arcOffset += 1;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.rotatePercent = 0;\n      } else if (this.rotatePercent < 0) {\n        this._arcOffset -= 1;\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        } else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.rotatePercent = 1 + this.rotatePercent;\n      }\n    } else {\n      this.isAutoMoving = false;\n      this._arcOffset = this.autoTargetOffset;\n      this.rotatePercent = 0;\n    }\n  }\n\n  transpose(i) {\n    // `target` is the index of the neighboring arc\n    // in the direction that we are rotating\n    let target = i - 1;\n\n    if (target < 0) {\n      target = this._arcs.length + target;\n    } else if (target >= this._arcs.length) {\n      target = target % this._arcs.length;\n    } // the start/end radians are pre-calculated when arcs are added/deleted\n    //\n\n\n    const realStart = this.arcStartEndPoints[i].start;\n    let startDiff = this.arcStartEndPoints[target].start - realStart;\n    const realEnd = this.arcStartEndPoints[i].end;\n    let endDiff = this.arcStartEndPoints[target].end - realEnd;\n\n    if (i === 1) {\n      startDiff = startDiff * -1;\n      endDiff = -utils.PI2 + endDiff;\n    }\n\n    let currentStart = startDiff * this.rotatePercent + realStart;\n    let currentEnd = endDiff * this.rotatePercent + realEnd;\n\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    } else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    } else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n\n    return [currentStart, currentEnd];\n  }\n\n  mouseEvent(fingerX, fingerY, compRadian) {\n    for (let arc of this.expandedArcs) {\n      const port = arc.getTouchedPort(fingerX, fingerY);\n\n      if (port) {\n        this.params.touchedPort = port;\n        this._touched = false;\n        return;\n      }\n    }\n\n    this._touched = true; // see which arc was touched\n\n    for (let arc of this._arcs) {\n      if (compRadian > arc.start && compRadian < arc.end) {\n        arc.touched = true;\n        break;\n      }\n    }\n  }\n\n  rotateDrag() {\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = utils.PI - this._radiansMoved % utils.PI;\n      this._radiansMoved *= -1;\n    }\n\n    if (!this.touched) {\n      this._radiansMoved *= circleDefaults.rotateFeedback;\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - relativeMovement % 1;\n    } else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + relativeMovement % 1;\n    }\n\n    if (relativeMovement && relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      } else {\n        this.direction = 1;\n      }\n\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.rotatePercent -= animStep;\n\n      if (this.rotatePercent >= 1) {\n        this._arcOffset += 1;\n        if (this._arcOffset >= this._arcs.length) this._arcOffset -= this._arcs.length;\n        this.rotatePercent -= 1;\n      } else if (this.rotatePercent < 0) {\n        this._arcOffset -= 1;\n        if (this._arcOffset < 0) this._arcOffset += this._arcs.length;\n        this.rotatePercent += 1;\n      }\n    }\n  }\n\n  createArc(name, color, id) {\n    return new Arc(this.params, this, this._type, name, id, color);\n  }\n\n  addArc(arc) {\n    this._arcs.push(arc);\n\n    this.updateDimensionStuff();\n  }\n\n  deleteArc(arc) {\n    for (let _ref of this._arcs.entries()) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      let i = _ref2[0];\n      let a = _ref2[1];\n\n      if (arc === a) {\n        this._arcs.splice(i, 1);\n\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n\n        this.updateDimensionStuff();\n        return;\n      }\n    }\n  }\n\n  deleteArcFromId(id) {\n    const arc = this.getArcFromId(id);\n\n    if (arc) {\n      this.deleteArc(arc);\n    }\n  }\n\n  getArcFromId(id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n\n    return undefined;\n  }\n\n  getArcById(id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n\n    return undefined;\n  }\n\n  updateDimensionStuff() {\n    this.arcStartEndPoints = [];\n\n    if (this._arcs.length === 1) {\n      this.arcStartEndPoints = [{\n        'start': utils.PI / 2,\n        'end': utils.PI / 2\n      }];\n    } else if (this._arcs.length === 2) {\n      this.arcStartEndPoints = [{\n        'start': utils.PI,\n        'end': utils.PI2\n      }, {\n        'start': 0,\n        'end': utils.PI\n      }];\n    } else {\n      this.arcStartEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n\n      for (let i = 1; i < this._arcs.length; i++) {\n        this.arcStartEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  isCloseTo(x, y) {\n    const distFromCenter = utils.getDistance(this._x, this._y, x, y);\n    const w = this._lineWidth / 2;\n    const outerRad = this._radiusPercentage * this.params.screenSize + w;\n    const innerRad = this._radiusPercentage * this.params.screenSize - w;\n\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n\n    return false;\n  }\n\n  tapEvent() {\n    if (this._touched) {\n      for (let i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered() {\n    this._touched = false;\n\n    for (let i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n    }\n  }\n\n}\n\nexport { Circle };","map":{"version":3,"sources":["/Users/andy/Documents/patchbay-react/patchbay-react/src/modules/Circle.js"],"names":["utils","Arc","circleDefaults","autoStepSize","rotateFeedback","padding","PI","textXOffsetScaler","arcTextScaler","typeFontSizeScaler","labelOffsetYScaler","Circle","constructor","params","type","radiusPercentage","thicknessPercentage","context","_type","_radiusPercentage","relativeLineWidth","_lineWidth","undefined","_x","_y","_touched","_arcs","arcStartEndPoints","_arcOffset","rotatePercent","_radiansMoved","isAutoMoving","autoTargetOffset","autoStepTotal","autoStepCount","touched","arcs","x","y","radiansMoved","newVal","holdsTouchedPort","port","touchedPort","Boolean","holdsHoveredPort","hoveredPort","getExpandedArcs","push","length","update","updateAutoMoving","rotateDrag","totalArcs","Math","floor","screenSize","i","nonHighlightedIndex","arcIndex","points","transpose","sizeScaler","onScreenUpdate","drawArcs","save","translate","textAlign","typeFontSize","inType","typeYOffset","font","fillStyle","colors","black","fillText","toUpperCase","arc0","arc0FontSize","xOffset0","outType","color","min","name","arc1","arc1FontSize","xOffset1","drawArc","restore","drawNames","arc","isSelected","drawAllPortNames","parentArc","parent","drawPortName","drawPorts","startAutoMove","newOffset","moveUp","moveDown","arcsToMove","abs","target","realStart","start","startDiff","realEnd","end","endDiff","PI2","currentStart","currentEnd","mouseEvent","fingerX","fingerY","compRadian","expandedArcs","getTouchedPort","relativeMovement","direction","animStep","createArc","id","addArc","updateDimensionStuff","deleteArc","entries","a","splice","deleteArcFromId","getArcFromId","getArcById","smallerWidth","isCloseTo","distFromCenter","getDistance","w","outerRad","innerRad","tapEvent","clearTouchedHovered"],"mappings":"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","sourcesContent":["import * as utils from './DrawUtils'\nimport { Arc } from './Arc'\n\nconst circleDefaults = {\n  autoStepSize: 0.1,\n  rotateFeedback: 0.85,\n  padding: utils.PI / 200,\n  textXOffsetScaler: 0.075,\n  arcTextScaler: 0.04,\n  typeFontSizeScaler: 0.025,\n  labelOffsetYScaler: 2\n};\n\nclass Circle {\n  constructor (params, type, radiusPercentage, thicknessPercentage) {\n    this.params = params;\n    this.context = params.context;\n\n    this._type = type;\n\n    this._radiusPercentage = radiusPercentage;\n    this.relativeLineWidth = thicknessPercentage;\n    this._lineWidth = undefined;\n\n    this._x = 0;\n    this._y = 0;\n\n    this._touched = false;\n\n    this._arcs = [];\n\n    this.arcStartEndPoints = [];\n    this._arcOffset = 0;\n    this.rotatePercent = 0;\n    this._radiansMoved = 0;\n\n    this.isAutoMoving = false;\n    this.autoTargetOffset = 0;\n    this.autoStepTotal = 0;\n    this.autoStepCount = 0;\n  }\n\n  // GETTERS\n\n  get type () { return this._type; }\n\n  get touched () { return this._touched; }\n\n  get arcs () { return this._arcs; }\n\n  get x () { return this._x; }\n\n  get y () { return this._y; }\n\n  // SETTERS\n\n  set radiansMoved (newVal) { this._radiansMoved = newVal; }\n\n  set x (newVal) { this._x = newVal; }\n\n  set y (newVal) { this._y = newVal; }\n\n  holdsTouchedPort () {\n    const port = this.params.touchedPort;\n    return Boolean(port && port.type === this.type);\n  }\n\n  holdsHoveredPort () {\n    const port = this.params.hoveredPort;\n    return Boolean(port && port.type === this.type);\n  }\n\n  getExpandedArcs () {\n    const arcs = [this._arcs[this._arcOffset]];\n    if (this.rotatePercent > 0 && this.rotatePercent < 1) {\n      arcs.push(this._arcs[(this._arcOffset + 1) % this._arcs.length]);\n    }\n    return arcs;\n  }\n\n  update () {\n    if (this.isAutoMoving) {\n      this.updateAutoMoving();\n    }\n    else {\n      this.rotateDrag();\n    }\n    const totalArcs = this._arcs.length;\n    if (this._arcOffset < totalArcs) {\n      this._lineWidth = Math.floor(this.relativeLineWidth * this.params.screenSize);\n      for (let i = 0; i < totalArcs; i++) {\n        const nonHighlightedIndex = (i + this._arcOffset) % totalArcs;\n        const arcIndex = (i === 0) ? this._arcOffset : nonHighlightedIndex;\n        const points = this.transpose(i);\n        const sizeScaler = (this._arcOffset === arcIndex) ? 1 - this.rotatePercent : this.rotatePercent;\n        this._arcs[arcIndex].onScreenUpdate(\n          this._radiusPercentage * this.params.screenSize,\n          this._lineWidth,\n          this.x,\n          this.y\n        )\n        this._arcs[arcIndex].update(\n          points[0] + circleDefaults.padding,\n          points[1] - circleDefaults.padding,\n          Boolean(i < 2),\n          sizeScaler\n        );\n      }\n    }\n  }\n\n  drawArcs () {\n    if (this._arcs.length > 0) {\n      this.context.save();\n      this.context.translate(this._x, this._y);\n      this.context.textAlign = 'center';\n\n      // draw the TYPE text in the center of the Circle\n      const typeFontSize = Math.floor(\n        this.params.screenSize * circleDefaults.typeFontSizeScaler);\n      let labelOffsetYScaler = circleDefaults.labelOffsetYScaler;\n      labelOffsetYScaler *= (this._type === this.params.inType) ? -1 : 1;\n      const typeYOffset = typeFontSize * labelOffsetYScaler;\n      this.context.font = utils.font(typeFontSize);\n      this.context.fillStyle = utils.colors.black();\n      this.context.fillText(this._type.toUpperCase(), 0, typeYOffset);\n\n      const arcTextScaler = Math.floor(this.params.screenSize * circleDefaults.arcTextScaler);\n\n      // then draw the currently displayed arc's name\n      const arc0 = this._arcs[this._arcOffset];\n      const arc0FontSize = arcTextScaler * arc0.sizeScaler;\n      let xOffset0 = this._lineWidth * arcTextScaler * this.rotatePercent;\n      if (arc0.type === this.params.outType) {\n        xOffset0 *= -1;\n      }\n      xOffset0 *= circleDefaults.textXOffsetScaler;\n      this.context.font = utils.font(arc0FontSize);\n      this.context.fillStyle = arc0.color(Math.min(arc0.sizeScaler, 1));\n      this.context.fillText(arc0.name, xOffset0, 0);\n\n      // draw the next-in-line Arc's label (fading in/out)\n      const arc1 = this._arcs[(this._arcOffset + 1) % this._arcs.length];\n      const arc1FontSize = arcTextScaler * arc1.sizeScaler;\n      let xOffset1 = this._lineWidth * arcTextScaler * (1 - this.rotatePercent);\n      if (arc1.type === this.params.outType) {\n        xOffset1 *= -1;\n      }\n      xOffset1 *= circleDefaults.textXOffsetScaler;\n      xOffset1 *= -1;\n      this.context.font = utils.font(arc1FontSize);\n      this.context.fillStyle = arc1.color(Math.min(arc1.sizeScaler, 1));\n      this.context.fillText(arc1.name, xOffset1, 0);\n\n      // now draw the actual child Arcs\n      for (let i = 0; i < this._arcs.length; i++) {\n        this._arcs[i].drawArc();\n      }\n\n      this.context.restore();\n    }\n  }\n\n  drawNames () {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n    if (!this.holdsTouchedPort()) {\n      for (let arc of this._arcs) {\n        if (arc.isSelected) {\n          arc.drawAllPortNames();\n        }\n      }\n    }\n    else {\n      // the touched port is in this circle, so only draw it's name\n      const parentArc = this.params.touchedPort.parent;\n      parentArc.drawPortName(this.params.touchedPort);\n    }\n    this.context.restore();\n  }\n\n  drawPorts () {\n    this.context.save();\n    this.context.translate(this._x, this._y);\n    for (let arc of this._arcs) {\n      if (arc.isSelected) {\n        arc.drawPorts();\n      }\n    }\n    this.context.restore();\n  }\n\n  startAutoMove (newOffset) {\n    this.autoTargetOffset = newOffset;\n    this.isAutoMoving = true;\n    const moveUp = newOffset - (this._arcOffset + this._arcs.length);\n    const moveDown = newOffset - this._arcOffset;\n    let arcsToMove = moveUp - this.rotatePercent;\n    if (Math.abs(moveUp) > Math.abs(moveDown)) {\n      if (Math.abs(moveDown) > this._arcs.length / 2) {\n        arcsToMove = moveDown + this._arcs.length + this.rotatePercent;\n      }\n      else if (moveDown === 0) {\n        arcsToMove = (moveDown - this.rotatePercent) % this._arcs.length;\n      }\n      else {\n        arcsToMove = (moveDown + this.rotatePercent) % this._arcs.length;\n      }\n    }\n    this.autoStepSize = circleDefaults.autoStepSize;\n    this.autoStepTotal = arcsToMove / this.autoStepSize;\n    if (this.autoStepTotal < 0) {\n      this.autoStepTotal *= -1;\n      this.autoStepSize *= -1;\n    }\n    this.autoStepCount = 0;\n  }\n\n  updateAutoMoving () {\n    if (this.autoStepCount < this.autoStepTotal) {\n      this.rotatePercent += this.autoStepSize;\n      this.autoStepCount++;\n      if (this.rotatePercent >= 1) {\n        this._arcOffset += 1;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset<0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.rotatePercent = 0;\n      }\n      else if (this.rotatePercent < 0) {\n        this._arcOffset -= 1;\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = 0;\n        }\n        else if (this._arcOffset < 0) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.rotatePercent = 1 + this.rotatePercent;\n      }\n    }\n    else {\n      this.isAutoMoving = false;\n      this._arcOffset = this.autoTargetOffset;\n      this.rotatePercent = 0;\n    }\n  }\n\n  transpose (i) {\n    // `target` is the index of the neighboring arc\n    // in the direction that we are rotating\n    let target = i - 1;\n    if (target < 0) {\n      target = this._arcs.length + target;\n    }\n    else if (target >= this._arcs.length) {\n      target = target % this._arcs.length;\n    }\n    // the start/end radians are pre-calculated when arcs are added/deleted\n    //\n    const realStart = this.arcStartEndPoints[i].start;\n    let startDiff = this.arcStartEndPoints[target].start - realStart;\n    const realEnd = this.arcStartEndPoints[i].end;\n    let endDiff = this.arcStartEndPoints[target].end - realEnd;\n    if (i === 1) {\n      startDiff = startDiff * -1;\n      endDiff = -utils.PI2 + endDiff;\n    }\n\n    let currentStart = (startDiff * this.rotatePercent) + realStart;\n    let currentEnd = (endDiff * this.rotatePercent) + realEnd;\n    if (currentStart > utils.PI2) {\n      currentStart = currentStart % utils.PI2;\n    }\n    else if (currentStart < 0) {\n      currentStart += utils.PI2;\n    }\n    if (currentEnd > utils.PI2) {\n      currentEnd = currentEnd % utils.PI2;\n    }\n    else if (currentEnd < 0) {\n      currentEnd += utils.PI2;\n    }\n    return [currentStart, currentEnd];\n  }\n\n  mouseEvent (fingerX, fingerY, compRadian) {\n    for (let arc of this.expandedArcs) {\n      const port = arc.getTouchedPort(fingerX, fingerY);\n      if (port) {\n        this.params.touchedPort = port;\n        this._touched = false;\n        return;\n      }\n    }\n    this._touched = true;\n    // see which arc was touched\n    for (let arc of this._arcs) {\n      if (compRadian > arc.start && compRadian < arc.end) {\n        arc.touched = true;\n        break;\n      }\n    }\n  }\n\n  rotateDrag () {\n    if (this._radiansMoved > utils.PI / 2) {\n      this._radiansMoved = utils.PI - (this._radiansMoved % utils.PI);\n      this._radiansMoved *= -1;\n    }\n    if (!this.touched) {\n      this._radiansMoved *= circleDefaults.rotateFeedback;\n    }\n\n    let relativeMovement = this._radiansMoved / utils.PI2;\n    if (relativeMovement > 0.5) {\n      relativeMovement = 1 - (relativeMovement % 1);\n    }\n    else if (relativeMovement < -0.5) {\n      relativeMovement = 1 + (relativeMovement % 1);\n    }\n    if (relativeMovement && relativeMovement < 1 && relativeMovement > -1) {\n      if (Math.abs(relativeMovement) < 0) {\n        this.direction = -1;\n      }\n      else {\n        this.direction = 1;\n      }\n      const animStep = relativeMovement / (1 / this._arcs.length);\n      this.rotatePercent -= animStep;\n\n      if (this.rotatePercent >= 1) {\n        this._arcOffset += 1;\n        if (this._arcOffset >= this._arcs.length) this._arcOffset -= this._arcs.length;\n        this.rotatePercent -= 1;\n      }\n      else if (this.rotatePercent < 0) {\n        this._arcOffset -= 1;\n        if (this._arcOffset < 0) this._arcOffset += this._arcs.length;\n        this.rotatePercent += 1;\n      }\n    }\n  }\n\n  createArc (name, color, id) {\n    return new Arc(\n      this.params,\n      this,\n      this._type,\n      name,\n      id,\n      color\n    );\n  }\n\n  addArc (arc) {\n    this._arcs.push(arc);\n    this.updateDimensionStuff();\n  }\n\n  deleteArc (arc) {\n    for (let [i, a] of this._arcs.entries()) {\n      if (arc === a) {\n        this._arcs.splice(i, 1);\n        if (this._arcOffset >= this._arcs.length) {\n          this._arcOffset = this._arcs.length - 1;\n        }\n        this.updateDimensionStuff();\n        return;\n      }\n    }\n  }\n\n  deleteArcFromId (id) {\n    const arc = this.getArcFromId(id);\n    if (arc) {\n      this.deleteArc(arc);\n    }\n  }\n\n  getArcFromId (id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n    return undefined;\n  }\n\n  getArcById (id) {\n    for (let arc of this._arcs) {\n      if (arc.id === id) {\n        return arc;\n      }\n    }\n    return undefined;\n  }\n\n  updateDimensionStuff () {\n    this.arcStartEndPoints = [];\n    if (this._arcs.length === 1) {\n      this.arcStartEndPoints = [\n        {\n          'start': utils.PI / 2,\n          'end': utils.PI / 2\n        }\n      ];\n    }\n    else if (this._arcs.length === 2) {\n      this.arcStartEndPoints = [\n        {\n          'start': utils.PI,\n          'end': utils.PI2\n        },\n        {\n          'start': 0,\n          'end': utils.PI\n        },\n      ];\n    }\n    else{\n      this.arcStartEndPoints[0] = {\n        'start': utils.PI,\n        'end': utils.PI2\n      };\n      const smallerWidth = utils.PI / (this._arcs.length - 1);\n      for (let i = 1; i < this._arcs.length; i++) {\n        this.arcStartEndPoints[i] = {\n          'start': (i - 1) * smallerWidth,\n          'end': i * smallerWidth\n        };\n      }\n    }\n  }\n\n  isCloseTo (x, y) {\n    const distFromCenter = utils.getDistance(this._x, this._y, x, y);\n    const w = this._lineWidth / 2;\n    const outerRad = (this._radiusPercentage * this.params.screenSize) + w;\n    const innerRad = (this._radiusPercentage * this.params.screenSize) - w;\n    if (distFromCenter <= outerRad && distFromCenter >= innerRad) {\n      return true;\n    }\n    return false;\n  }\n\n  tapEvent () {\n    if (this._touched) {\n      for (let i = 0; i < this._arcs.length; i++) {\n        if (this._arcs[i].touched) {\n          this.startAutoMove(i);\n        }\n      }\n    }\n    this.clearTouchedHovered();\n  }\n\n  clearTouchedHovered () {\n    this._touched = false;\n    for (let i = 0; i < this._arcs.length; i++) {\n      this._arcs[i].touched = false;\n    }\n  }\n}\n\nexport { Circle }\n"]},"metadata":{},"sourceType":"module"}